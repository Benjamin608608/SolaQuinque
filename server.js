const express = require('express');
const cors = require('cors');
const path = require('path');
const OpenAI = require('openai');
const session = require('express-session');
const passport = require('passport');
require('dotenv').config();
const { MongoClient } = require('mongodb');
const fs = require('fs');
const { google } = require('googleapis');

const app = express();
const PORT = process.env.PORT || 3000;

// ÂÖ®Â±ÄËÆäÊï∏
let globalAssistant = null;
let processingRequests = new Map();
const CACHE_DURATION = 30 * 60 * 1000; // 30 ÂàÜÈêò
let assistantWarmupInterval = null; // ÂÆöÊúü‰øùÊ∫´Ë®àÊôÇÂô®

// ‰ΩúËÄÖÂ∞çÁÖßË°®
let authorTranslations = {};

// ËºâÂÖ•‰ΩúËÄÖÂ∞çÁÖßË°®
async function loadAuthorTranslations() {
    try {
        const fs = await import('fs');
        const path = await import('path');
        const filePath = path.join(process.cwd(), 'config', 'author-translations.json');
        
        if (fs.existsSync(filePath)) {
            const data = fs.readFileSync(filePath, 'utf8');
            authorTranslations = JSON.parse(data);
            console.log(`‚úÖ Â∑≤ËºâÂÖ•‰ΩúËÄÖÂ∞çÁÖßË°® (${Object.keys(authorTranslations).length} ‰Ωç‰ΩúËÄÖ)`);
        } else {
            console.warn('‚ö†Ô∏è ‰ΩúËÄÖÂ∞çÁÖßË°®Êñá‰ª∂‰∏çÂ≠òÂú®');
        }
    } catch (error) {
        console.error('‚ùå ËºâÂÖ•‰ΩúËÄÖÂ∞çÁÖßË°®Â§±Êïó:', error.message);
    }
}

// Áç≤Âèñ‰ΩúËÄÖÂêçÁ®±ÔºàÊ†πÊìöË™ûË®ÄÔºâ
function getAuthorName(englishName, language = 'zh') {
  if (!englishName) return '';
  
  if (language === 'zh' && authorTranslations.authors[englishName]) {
    return authorTranslations.authors[englishName];
  }
  return englishName;
}



// ËÆì express-session ÊîØÊè¥ proxy (Â¶Ç Railway/Heroku/Render)
app.set('trust proxy', 1);

// ÂàùÂßãÂåñ OpenAI ÂÆ¢Êà∂Á´Ø
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Ê®°ÂûãË®≠ÂÆöÔºöÂÑ™ÂÖà‰ΩøÁî®Áí∞Â¢ÉËÆäÊï∏ÔºàÈ†êË®≠ gpt-5ÔºâÔºåËã•Â§±ÊïóÂâáÂõûÈÄÄÂà∞ gpt-4o-mini
const PREFERRED_ASSISTANT_MODEL = process.env.OPENAI_ASSISTANT_MODEL || process.env.OPENAI_MODEL || 'gpt-5';

// Á∞°Êòì LRU/TTL Âø´ÂèñÔºöËÅñÁ∂ìÁ∂ìÊñáËß£Èáã & ÊØèÂç∑ÂêëÈáèÂ∫´ ID
const bibleExplainCache = new Map(); // key => { data, ts }
const BIBLE_EXPLAIN_TTL_MS = 1000 * 60 * 30; // 30 ÂàÜÈêò

const vectorStoreIdCache = new Map(); // name(lowercased) => { id, ts }
const VECTOR_STORE_ID_TTL_MS = 1000 * 60 * 60 * 6; // 6 Â∞èÊôÇ

function getBibleExplainCached(key) {
  const item = bibleExplainCache.get(key);
  if (!item) return null;
  if (Date.now() - item.ts > BIBLE_EXPLAIN_TTL_MS) {
    bibleExplainCache.delete(key);
    return null;
  }
  return item.data;
}

function setBibleExplainCached(key, data) {
  bibleExplainCache.set(key, { data, ts: Date.now() });
}

async function getVectorStoreIdCachedByName(name) {
  const k = (name || '').toLowerCase();
  const hit = vectorStoreIdCache.get(k);
  if (hit && Date.now() - hit.ts <= VECTOR_STORE_ID_TTL_MS) return hit.result;
  const result = await findVectorStoreIdByName(name);
  if (result) vectorStoreIdCache.set(k, { result, ts: Date.now() });
  return result;
}

// ‰Ω†ÁöÑÂêëÈáèË≥áÊñôÂ∫´ ID
const VECTOR_STORE_ID = process.env.VECTOR_STORE_ID || 'vs_6886f711eda0819189b6c017d6b96d23';

// MongoDB Atlas ÈÄ£Á∑ö
let mongoClient, loginLogsCollection;

async function connectToMongoDB() {
  if (!process.env.MONGO_URI) {
    console.warn('‚ö†Ô∏è  MONGO_URI Áí∞Â¢ÉËÆäÊï∏Êú™Ë®≠ÁΩÆÔºåMongoDB ÂäüËÉΩÂ∞á‰∏çÂèØÁî®');
    return;
  }
  
  try {
    mongoClient = new MongoClient(process.env.MONGO_URI, { 
      useUnifiedTopology: true,
      serverSelectionTimeoutMS: 5000,
      connectTimeoutMS: 10000
    });
    await mongoClient.connect();
    const db = mongoClient.db('theologian');
    loginLogsCollection = db.collection('loginLogs');
    console.log('‚úÖ Â∑≤ÈÄ£Á∑ö MongoDB Atlas (theologian.loginLogs)');
  } catch (err) {
    console.error('‚ùå ÈÄ£Á∑ö MongoDB Atlas Â§±Êïó:', err.message);
    console.log('üí° ÊáâÁî®Á®ãÂºèÂ∞áÁπºÁ∫åÈÅãË°åÔºå‰ΩÜÁôªÂÖ•Ë®òÈåÑÂäüËÉΩÂ∞á‰∏çÂèØÁî®');
  }
}

// ÂàùÂßãÂåñ MongoDB ÈÄ£Á∑ö
connectToMongoDB();

// Session ÈÖçÁΩÆÔºàÊîπËâØÁâàÔºåÊîØÊè¥ÁßªÂãïË®≠ÂÇôÔºâ
app.use(session({
  secret: process.env.SESSION_SECRET || 'your-secret-key',
  resave: false,
  saveUninitialized: true, // ÈúÄË¶ÅÁÇ∫ OAuth ÂàùÂßãË´ãÊ±Ç‰øùÂ≠òÊú™ÂàùÂßãÂåñÁöÑÊúÉË©±
  cookie: {
    secure: process.env.NODE_ENV === 'production', // Âè™Âú®ÁîüÁî¢Áí∞Â¢É‰ΩøÁî® secure
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24 Â∞èÊôÇ
    sameSite: 'lax' // ÊîπÂñÑÁßªÂãïË®≠ÂÇôÁõ∏ÂÆπÊÄßÔºàÂ∞ç OAuth ÂèãÂ•ΩÔºâ
  },
  name: 'theologian.sid' // Ëá™ÂÆöÁæ© session cookie ÂêçÁ®±
}));

// Passport ÈÖçÁΩÆ
app.use(passport.initialize());
app.use(passport.session());

// Passport Â∫èÂàóÂåñ
passport.serializeUser((user, done) => {
  done(null, user);
});

passport.deserializeUser((user, done) => {
  done(null, user);
});

// Ê¢ù‰ª∂ÊÄß Google OAuth ÈÖçÁΩÆ
if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
  const GoogleStrategy = require('passport-google-oauth20').Strategy;
  
  passport.use(new GoogleStrategy({
      clientID: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      callbackURL: process.env.GOOGLE_CALLBACK_URL || "http://localhost:3000/auth/google/callback"
    },
    function(accessToken, refreshToken, profile, cb) {
      // ÈÄôË£°ÂèØ‰ª•Ê∑ªÂä†Áî®Êà∂Ë≥áÊñôÂ∫´Â≠òÂÑ≤ÈÇèËºØ
      const user = {
        id: profile.id,
        email: profile.emails[0].value,
        name: profile.displayName,
        picture: profile.photos[0].value
      };
      return cb(null, user);
    }
  ));
} else {
  console.warn('‚ö†Ô∏è  Google OAuth ÊÜëË≠âÊú™Ë®≠ÁΩÆÔºåÁôªÂÖ•ÂäüËÉΩÂ∞á‰∏çÂèØÁî®');
  console.warn('   Ë´ãË®≠ÁΩÆ GOOGLE_CLIENT_ID Âíå GOOGLE_CLIENT_SECRET Áí∞Â¢ÉËÆäÊï∏');
}

// ‰∏≠Èñì‰ª∂Ë®≠ÁΩÆ
app.use(cors({
  origin: true, // ÂÖÅË®±ÊâÄÊúâ‰æÜÊ∫ê
  credentials: true, // ÂÖÅË®±ÊîúÂ∏∂ÊÜëË≠â
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));
app.use(express.json({ limit: '10mb' }));
app.use(express.static(path.join(__dirname, 'public')));
app.use('/data', express.static(path.join(__dirname, 'data')));

// Ë™çË≠â‰∏≠Èñì‰ª∂
function ensureAuthenticated(req, res, next) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ 
    success: false, 
    error: 'ÈúÄË¶ÅÁôªÂÖ•ÊâçËÉΩ‰ΩøÁî®Ê≠§ÂäüËÉΩ',
    requiresAuth: true 
  });
}

// Ê™¢Ê∏¨ÊòØÂê¶ÁÇ∫ LINE ÁÄèË¶ΩÂô®
function isLineBrowser(userAgent) {
  return userAgent && (
    userAgent.includes('Line') || 
    userAgent.includes('LINE') ||
    userAgent.includes('line')
  );
}

// Ê™¢Ê∏¨ÊòØÂê¶ÁÇ∫ÂÖßÂª∫ÁÄèË¶ΩÂô®
function isEmbeddedBrowser(userAgent) {
  return userAgent && (
    userAgent.includes('Line') ||
    userAgent.includes('Instagram') ||
    userAgent.includes('Facebook') ||
    userAgent.includes('Twitter') ||
    userAgent.includes('WhatsApp') ||
    userAgent.includes('Telegram') ||
    userAgent.includes('WeChat')
  );
}

// Áç≤ÂèñÁï∂ÂâçÂÆåÊï¥ URL
function getCurrentUrl(req) {
  const protocol = req.headers['x-forwarded-proto'] || req.protocol;
  const host = req.headers['x-forwarded-host'] || req.headers.host;
  return `${protocol}://${host}${req.originalUrl}`;
}

// Ë™çË≠âË∑ØÁî± - ÂÉÖÂú® Google OAuth Â∑≤ÈÖçÁΩÆÊôÇÂïüÁî®
if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
  app.get('/auth/google', (req, res) => {
    const userAgent = req.get('User-Agent');
    const currentUrl = getCurrentUrl(req);
    
    // Ê™¢Ê∏¨ÊòØÂê¶ÁÇ∫ÂÖßÂª∫ÁÄèË¶ΩÂô®
    if (isEmbeddedBrowser(userAgent)) {
      return res.status(200).send(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Ë´ã‰ΩøÁî®Â§ñÈÉ®ÁÄèË¶ΩÂô®ÁôªÂÖ•</title>
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              margin: 0;
              padding: 20px;
              min-height: 100vh;
              display: flex;
              align-items: center;
              justify-content: center;
            }
            .container {
              background: white;
              padding: 40px;
              border-radius: 12px;
              box-shadow: 0 8px 32px rgba(0,0,0,0.1);
              text-align: center;
              max-width: 500px;
            }
            .icon {
              font-size: 48px;
              margin-bottom: 20px;
            }
            h1 {
              color: #333;
              margin-bottom: 20px;
            }
            p {
              color: #666;
              line-height: 1.6;
              margin-bottom: 20px;
            }
            .btn {
              background: #4285f4;
              color: white;
              padding: 12px 24px;
              border: none;
              border-radius: 6px;
              text-decoration: none;
              display: inline-block;
              margin: 10px;
              font-size: 16px;
              cursor: pointer;
            }
            .btn:hover {
              background: #3367d6;
            }
            .btn-secondary {
              background: #6c757d;
            }
            .btn-secondary:hover {
              background: #545b62;
            }
            .steps {
              text-align: left;
              background: #f8f9fa;
              padding: 20px;
              border-radius: 8px;
              margin: 20px 0;
            }
            .steps ol {
              margin: 0;
              padding-left: 20px;
            }
            .steps li {
              margin-bottom: 10px;
              color: #555;
            }
            .url-box {
              background: #e9ecef;
              padding: 10px;
              border-radius: 6px;
              margin: 15px 0;
              word-break: break-all;
              font-family: monospace;
              font-size: 12px;
            }
            .copy-btn {
              background: #28a745;
              color: white;
              padding: 8px 16px;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 14px;
              margin-top: 10px;
            }
            .copy-btn:hover {
              background: #218838;
            }
            .success {
              color: #28a745;
              font-weight: bold;
              margin-top: 10px;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="icon">üåê</div>
            <h1>Ë´ã‰ΩøÁî®Â§ñÈÉ®ÁÄèË¶ΩÂô®ÁôªÂÖ•</h1>
            <p>Áî±Êñº Google ÂÆâÂÖ®ÊîøÁ≠ñÔºåÁÑ°Ê≥ïÂú®Áï∂ÂâçÁÄèË¶ΩÂô®‰∏≠ÂÆåÊàêÁôªÂÖ•„ÄÇ</p>
            
            <div class="steps">
              <h3>Ëß£Ê±∫Ê≠•È©üÔºö</h3>
              <ol>
                <li>ÈªûÊìäÂè≥‰∏äËßíÁöÑ„Äå...„ÄçÊàñ„ÄåÊõ¥Â§öÈÅ∏È†Ö„Äç</li>
                <li>ÈÅ∏Êìá„ÄåÂú®ÁÄèË¶ΩÂô®‰∏≠ÈñãÂïü„ÄçÊàñ„ÄåË§áË£ΩÈÄ£Áµê„Äç</li>
                <li>Âú® Chrome„ÄÅSafari Á≠âÂ§ñÈÉ®ÁÄèË¶ΩÂô®‰∏≠ÈñãÂïü</li>
                <li>ÂÆåÊàê Google ÁôªÂÖ•</li>
              </ol>
            </div>
            
            <div class="url-box" id="urlBox">${currentUrl}</div>
            <button class="copy-btn" onclick="copyUrl()">Ë§áË£ΩÈÄ£Áµê</button>
            <div id="copyStatus"></div>
            
            <div style="margin-top: 20px;">
              <a href="/" class="btn btn-secondary">ËøîÂõûÈ¶ñÈ†Å</a>
              <button class="btn" onclick="openInNewWindow()">Âú®Êñ∞Ë¶ñÁ™óÈñãÂïü</button>
            </div>
          </div>
          
          <script>
            function copyUrl() {
              const url = '${currentUrl}';
              if (navigator.clipboard) {
                navigator.clipboard.writeText(url).then(() => {
                  document.getElementById('copyStatus').innerHTML = '<div class="success">‚úÖ ÈÄ£ÁµêÂ∑≤Ë§áË£ΩÂà∞Ââ™Ë≤ºÁ∞ø</div>';
                });
              } else {
                // ÈôçÁ¥öÊñπÊ°à
                const textArea = document.createElement('textarea');
                textArea.value = url;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                document.getElementById('copyStatus').innerHTML = '<div class="success">‚úÖ ÈÄ£ÁµêÂ∑≤Ë§áË£ΩÂà∞Ââ™Ë≤ºÁ∞ø</div>';
              }
            }
            
            function openInNewWindow() {
              const url = '${currentUrl}';
              try {
                window.open(url, '_blank');
              } catch (e) {
                alert('ÁÑ°Ê≥ïÈñãÂïüÊñ∞Ë¶ñÁ™óÔºåË´ãÊâãÂãïË§áË£ΩÈÄ£ÁµêÂà∞Â§ñÈÉ®ÁÄèË¶ΩÂô®');
              }
            }
            
            // Ëá™ÂãïÂòóË©¶ÈñãÂïüÊñ∞Ë¶ñÁ™óÔºàÂ¶ÇÊûúÂèØËÉΩÔºâ
            setTimeout(() => {
              try {
                window.open('${currentUrl}', '_blank');
              } catch (e) {
                // ÈùúÈªòÂ§±Êïó
              }
            }, 1000);
          </script>
        </body>
        </html>
      `);
    }
    
    // Ê≠£Â∏∏ÊµÅÁ®ã
    passport.authenticate('google', { 
      scope: ['profile', 'email'],
      prompt: 'select_account',
      access_type: 'offline',
      include_granted_scopes: true
    })(req, res);
  });

  app.get('/auth/google/callback', 
    passport.authenticate('google', { failureRedirect: '/' }),
    async function(req, res) {
      // ÂØ´ÂÖ•ÁôªÂÖ•Á¥ÄÈåÑÂà∞ MongoDB Atlas
      if (loginLogsCollection && req.user) {
        try {
          await loginLogsCollection.insertOne({
            email: req.user.email,
            name: req.user.name,
            loginAt: new Date(),
            googleId: req.user.id,
            picture: req.user.picture
          });
          console.log(`[ÁôªÂÖ•Á¥ÄÈåÑ] ${req.user.email} ${req.user.name}`);
        } catch (err) {
          console.error('ÂØ´ÂÖ•ÁôªÂÖ•Á¥ÄÈåÑÂ§±Êïó:', err.message);
        }
      }
      res.redirect('/');
    }
  );
} else {
  // Â¶ÇÊûú Google OAuth Êú™ÈÖçÁΩÆÔºåÊèê‰æõÂèãÂ•ΩÁöÑÈåØË™§È†ÅÈù¢
  app.get('/auth/google', (req, res) => {
    res.status(200).send(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Google ÁôªÂÖ•Êö´ÊôÇ‰∏çÂèØÁî®</title>
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          .container {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 500px;
          }
          .icon {
            font-size: 48px;
            margin-bottom: 20px;
          }
          h1 {
            color: #333;
            margin-bottom: 20px;
          }
          p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 20px;
          }
          .btn {
            background: #4285f4;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            text-decoration: none;
            display: inline-block;
            margin: 10px;
            transition: background 0.3s;
          }
          .btn:hover {
            background: #3367d6;
          }
          .btn-secondary {
            background: #6c757d;
          }
          .btn-secondary:hover {
            background: #5a6268;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="icon">üîß</div>
          <h1>Google ÁôªÂÖ•Êö´ÊôÇ‰∏çÂèØÁî®</h1>
          <p>Google OAuth ÂäüËÉΩÂ∞öÊú™ÈÖçÁΩÆ„ÄÇÁÆ°ÁêÜÂì°Ê≠£Âú®Ë®≠ÁΩÆ‰∏≠ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ</p>
          <p>Â¶ÇÊûúÊÇ®ÊòØÁÆ°ÁêÜÂì°ÔºåË´ãÂèÉËÄÉ <code>scripts/setup-google-oauth.md</code> Êñá‰ª∂ÈÄ≤Ë°åË®≠ÁΩÆ„ÄÇ</p>
          <a href="/" class="btn">ËøîÂõûÈ¶ñÈ†Å</a>
          <a href="/api/health" class="btn btn-secondary">Ê™¢Êü•Á≥ªÁµ±ÁãÄÊÖã</a>
        </div>
      </body>
      </html>
    `);
  });
}

app.get('/auth/logout', function(req, res, next) {
  req.logout(function(err) {
    if (err) { return next(err); }
    res.redirect('/');
  });
});



// Áç≤ÂèñÁî®Êà∂Ë≥áË®ä
app.get('/api/user', (req, res) => {
  if (req.isAuthenticated()) {
    res.json({
      success: true,
      user: {
        id: req.user.id,
        email: req.user.email,
        name: req.user.name,
        picture: req.user.picture
      }
    });
  } else {
    res.json({
      success: false,
      user: null
    });
  }
});

// Áç≤ÂèñÊñá‰ª∂ÂêçÁ®±ÁöÑÂáΩÊï∏
async function getFileName(fileId, language = 'zh') {
  try {
    const file = await openai.files.retrieve(fileId);
    let fileName = file.filename || `Ê™îÊ°à-${fileId.substring(0, 8)}`;
    fileName = fileName.replace(/\.(txt|pdf|docx?|rtf|md)$/i, '');
    
    console.log(`üîç ÂéüÂßãÊñá‰ª∂Âêç: "${fileName}"`);
    
    // ÂòóË©¶ÂæûÊ™îÊ°àÂêçÁ®±‰∏≠ÊèêÂèñ‰ΩúËÄÖÂêçÁ®±‰∏¶ÁøªË≠Ø
    // ÊîØÊè¥ÂÖ©Á®ÆÊ†ºÂºèÔºö
    // 1. ÈñãÈ†≠Ê†ºÂºèÔºöHerman Bavinck (1854-1921) Philosophy of Revelation
    // 2. ÊñπÊã¨ËôüÊ†ºÂºèÔºö[Charles Haddon Spurgeon (1834-1892)] Spurgeon's Sermons
    
    let translatedAuthorName = null;
    
    // Ê™¢Êü•ÊñπÊã¨ËôüÊ†ºÂºè [Author Name (Year)] Êàñ [Author Name]
    const bracketMatch = fileName.match(/\[([^\]\n]+?)\]/);
    if (bracketMatch) {
      const bracketContent = bracketMatch[1].trim();
      console.log(`üîç ÊñπÊã¨ËôüÊ†ºÂºè - ÊèêÂèñÂà∞ÂÖßÂÆπ: "${bracketContent}"`);
      
      // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´Âπ¥‰ªΩÊ†ºÂºè (Year)
      const yearMatch = bracketContent.match(/\(([^)]+)\)/);
      if (yearMatch) {
        // ÊúâÂπ¥‰ªΩÁöÑÊ†ºÂºèÔºö[Author Name (Year)]
        const englishAuthorName = bracketContent.replace(/\([^)]+\)/, '').trim();
        console.log(`üîç ÊñπÊã¨ËôüÊ†ºÂºèÔºàÊúâÂπ¥‰ªΩÔºâ- ÊèêÂèñÂà∞‰ΩúËÄÖÂêçÁ®±: "${englishAuthorName}"`);
        
        // ÂòóË©¶ÂÆåÊï¥ÂåπÈÖçÔºàÂåÖÂê´Âπ¥‰ªΩÔºâ
        const fullNameWithYear = bracketContent;
        let translatedAuthorName = getAuthorName(fullNameWithYear, language);
        console.log(`üîç ÊñπÊã¨ËôüÂÆåÊï¥ÂåπÈÖç: "${fullNameWithYear}" -> "${translatedAuthorName}"`);
        
        // Â¶ÇÊûúÂÆåÊï¥ÂåπÈÖçÊ≤íÊúâÁøªË≠ØÔºåÂòóË©¶Âè™ÂåπÈÖç‰ΩúËÄÖÂêçÔºà‰∏çÂê´Âπ¥‰ªΩÔºâ
        if (!translatedAuthorName || translatedAuthorName === fullNameWithYear) {
          translatedAuthorName = getAuthorName(englishAuthorName, language);
          console.log(`üîç ÊñπÊã¨ËôüÈÉ®ÂàÜÂåπÈÖç: "${englishAuthorName}" -> "${translatedAuthorName}"`);
        }
        
        // Â¶ÇÊûúÊâæÂà∞‰∫ÜÁøªË≠ØÔºåÊõøÊèõÊ™îÊ°àÂêçÁ®±
        if (translatedAuthorName && translatedAuthorName !== englishAuthorName) {
          // ÊõøÊèõÊñπÊã¨ËôüÂÖßÁöÑ‰ΩúËÄÖÂêçÁ®±Ôºå‰øùÊåÅÂπ¥‰ªΩ
          const year = yearMatch[1];
          const originalBracket = `[${bracketContent}]`;
          const translatedBracket = `[${translatedAuthorName} (${year})]`;
          fileName = fileName.replace(originalBracket, translatedBracket);
          console.log(`‚úÖ ÊñπÊã¨ËôüÁøªË≠ØÊàêÂäü: "${originalBracket}" -> "${translatedBracket}"`);
        }
      } else {
        // Ê≤íÊúâÂπ¥‰ªΩÁöÑÊ†ºÂºèÔºö[Author Name]
        const englishAuthorName = bracketContent;
        console.log(`üîç ÊñπÊã¨ËôüÊ†ºÂºèÔºàÁÑ°Âπ¥‰ªΩÔºâ- ÊèêÂèñÂà∞‰ΩúËÄÖÂêçÁ®±: "${englishAuthorName}"`);
        
        const translatedAuthorName = getAuthorName(englishAuthorName, language);
        console.log(`üîç ÊñπÊã¨ËôüÁÑ°Âπ¥‰ªΩÂåπÈÖç: "${englishAuthorName}" -> "${translatedAuthorName}"`);
        
        // Â¶ÇÊûúÊâæÂà∞‰∫ÜÁøªË≠ØÔºåÊõøÊèõÊ™îÊ°àÂêçÁ®±
        if (translatedAuthorName && translatedAuthorName !== englishAuthorName) {
          const originalBracket = `[${englishAuthorName}]`;
          const translatedBracket = `[${translatedAuthorName}]`;
          fileName = fileName.replace(originalBracket, translatedBracket);
          console.log(`‚úÖ ÊñπÊã¨ËôüÁøªË≠ØÊàêÂäü: "${originalBracket}" -> "${translatedBracket}"`);
        }
      }
    } else {
      // Ê™¢Êü•ÈñãÈ†≠Ê†ºÂºè Author Name (Year)
      const authorMatch = fileName.match(/^([^(]+?)\s*\(/);
      if (authorMatch) {
        const englishAuthorName = authorMatch[1].trim();
        console.log(`üîç ÈñãÈ†≠Ê†ºÂºè - ÊèêÂèñÂà∞‰ΩúËÄÖÂêçÁ®±: "${englishAuthorName}"`);
        
        // ÂòóË©¶ÂÆåÊï¥ÂåπÈÖçÔºàÂåÖÂê´Âπ¥‰ªΩÔºâ
        const fullNameWithYear = fileName.match(/^([^(]+?\([^)]+\))/);
        if (fullNameWithYear) {
          translatedAuthorName = getAuthorName(fullNameWithYear[1], language);
          console.log(`üîç ÈñãÈ†≠ÂÆåÊï¥ÂåπÈÖç: "${fullNameWithYear[1]}" -> "${translatedAuthorName}"`);
        }
        
        // Â¶ÇÊûúÊ≤íÊúâÊâæÂà∞ÔºåÂòóË©¶Âè™ÂåπÈÖç‰ΩúËÄÖÂêçÔºà‰∏çÂê´Âπ¥‰ªΩÔºâ
        if (!translatedAuthorName || translatedAuthorName === fullNameWithYear[1]) {
          translatedAuthorName = getAuthorName(englishAuthorName, language);
          console.log(`üîç ÈñãÈ†≠ÈÉ®ÂàÜÂåπÈÖç: "${englishAuthorName}" -> "${translatedAuthorName}"`);
        }
        
        // Â¶ÇÊûúÊâæÂà∞‰∫ÜÁøªË≠ØÔºåÊõøÊèõÊ™îÊ°àÂêçÁ®±
        if (translatedAuthorName && translatedAuthorName !== englishAuthorName) {
          // ÊõøÊèõ‰ΩúËÄÖÂêçÈÉ®ÂàÜÔºà‰øùÊåÅÂπ¥‰ªΩ‰∏çËÆäÔºâ
          fileName = fileName.replace(englishAuthorName, translatedAuthorName);
          console.log(`‚úÖ ÈñãÈ†≠Ê†ºÂºèÁøªË≠ØÊàêÂäü: "${englishAuthorName}" -> "${translatedAuthorName}"`);
        } else if (fullNameWithYear) {
          // Â¶ÇÊûúÂÆåÊï¥ÂåπÈÖçÊúâÁøªË≠ØÔºå‰ΩøÁî®ÂÆåÊï¥ÂåπÈÖçÁöÑÁøªË≠Ø
          const fullName = fullNameWithYear[1];
          const translatedFullName = getAuthorName(fullName, language);
          if (translatedFullName && translatedFullName !== fullName) {
            // ÊõøÊèõÊï¥ÂÄãÂÆåÊï¥ÂêçÁ®±
            fileName = fileName.replace(fullName, translatedFullName);
            console.log(`‚úÖ ÈñãÈ†≠ÂÆåÊï¥ÁøªË≠ØÊàêÂäü: "${fullName}" -> "${translatedFullName}"`);
          }
        }
      }
    }
    
    console.log(`üìÑ ÊúÄÁµÇÊñá‰ª∂Âêç: "${fileName}"`);
    return fileName;
  } catch (error) {
    console.warn(`ÁÑ°Ê≥ïÁç≤ÂèñÊ™îÊ°àÂêçÁ®± ${fileId}:`, error.message);
    return `Ê™îÊ°à-${fileId.substring(0, 8)}`;
  }
}

// ËôïÁêÜÂºïÁî®Ê®ôË®ò‰∏¶ËΩâÊèõÁÇ∫Á∂≤È†ÅÊ†ºÂºèÁöÑÂáΩÊï∏
async function processAnnotationsInText(text, annotations, language = 'zh') {
  console.log(`üîç processAnnotationsInText Ë¢´Ë™øÁî® - Ë™ûË®Ä: ${language}`);
  console.log(`üìù ÂéüÂßãÊñáÊú¨Èï∑Â∫¶: ${text.length}`);
  console.log(`üìù Ë®ªËß£Êï∏Èáè: ${annotations ? annotations.length : 0}`);
  
  let processedText = text;
  const sourceMap = new Map();
  const usedSources = new Map();
  let citationCounter = 1;
  
  if (annotations && annotations.length > 0) {
    // ‰∏¶Ë°åÈ†êËôïÁêÜÊâÄÊúâÊ™îÊ°àÂêçÁ®±
    const fileProcessingPromises = [];
    const annotationMap = new Map();
    
    for (const annotation of annotations) {
      if (annotation.type === 'file_citation' && annotation.file_citation) {
        const fileId = annotation.file_citation.file_id;
        const quote = annotation.file_citation.quote || '';
        
        // ‰∏¶Ë°åËôïÁêÜÊ™îÊ°àÂêçÁ®±
        const fileNamePromise = getFileName(fileId, language);
        fileProcessingPromises.push(fileNamePromise);
        annotationMap.set(annotation, { fileId, quote, fileNamePromise });
      }
    }
    
    // Á≠âÂæÖÊâÄÊúâÊ™îÊ°àÂêçÁ®±ËôïÁêÜÂÆåÊàê
    const fileNames = await Promise.all(fileProcessingPromises);
    let fileNameIndex = 0;
    
    for (const annotation of annotations) {
      if (annotation.type === 'file_citation' && annotation.file_citation) {
        const { fileId, quote } = annotationMap.get(annotation);
        const fileName = fileNames[fileNameIndex++];
        
        let citationIndex;
        if (usedSources.has(fileId)) {
          citationIndex = usedSources.get(fileId);
        } else {
          citationIndex = citationCounter++;
          usedSources.set(fileId, citationIndex);
          sourceMap.set(citationIndex, {
            fileName,
            quote,
            fileId
          });
        }
        
        const originalText = annotation.text;
        console.log(`üìÑ ËôïÁêÜË®ªËß£ ${citationCounter}: "${originalText}"`);
        
        if (originalText) {
          // ÂòóË©¶ÁøªË≠ØË®ªËß£ÊñáÊú¨‰∏≠ÁöÑ‰ΩúËÄÖÂêçÁ®±
          let translatedText = originalText;
          
          // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´‰ΩúËÄÖÂêçÁ®±Ê†ºÂºè [Author Name (Year)]
          const authorMatch = originalText.match(/\[([^(]+?)\s*\([^)]+\)\]/);
          if (authorMatch) {
            const fullAuthorName = authorMatch[1].trim();
            
            // ÂòóË©¶Â§öÁ®ÆÂåπÈÖçÊñπÂºè‰æÜÊâæÂà∞ÁøªË≠Ø
            let translatedAuthorName = null;
            
            // 1. ÂòóË©¶ÂÆåÊï¥ÂåπÈÖçÔºàÂåÖÂê´Âπ¥‰ªΩÔºâ
            const fullNameWithYear = originalText.match(/\[([^(]+?\([^)]+\))\]/);
            if (fullNameWithYear) {
              translatedAuthorName = getAuthorName(fullNameWithYear[1], language);
            }
            
            // 2. Â¶ÇÊûúÊ≤íÊúâÊâæÂà∞ÔºåÂòóË©¶Âè™ÂåπÈÖç‰ΩúËÄÖÂêçÔºà‰∏çÂê´Âπ¥‰ªΩÔºâ
            if (!translatedAuthorName || translatedAuthorName === fullNameWithYear[1]) {
              translatedAuthorName = getAuthorName(fullAuthorName, language);
            }
            
            if (translatedAuthorName && translatedAuthorName !== fullAuthorName) {
              // ÊõøÊèõ‰ΩúËÄÖÂêçÁ®±Ôºå‰øùÊåÅÂπ¥‰ªΩÂíåÊ†ºÂºè
              translatedText = originalText.replace(fullAuthorName, translatedAuthorName);
              console.log(`‚úÖ ÈÉ®ÂàÜÁøªË≠ØÊàêÂäü: "${originalText}" -> "${translatedText}"`);
            } else if (fullNameWithYear) {
              // Â¶ÇÊûúÂÆåÊï¥ÂåπÈÖçÊúâÁøªË≠ØÔºå‰ΩøÁî®ÂÆåÊï¥ÂåπÈÖçÁöÑÁøªË≠Ø
              const fullName = fullNameWithYear[1];
              const translatedFullName = getAuthorName(fullName, language);
              if (translatedFullName && translatedFullName !== fullName) {
                // ÊõøÊèõÊï¥ÂÄãÂÆåÊï¥ÂêçÁ®±Ôºå‰ΩÜ‰øùÊåÅÂπ¥‰ªΩÊ†ºÂºè
                const yearMatch = fullName.match(/\(([^)]+)\)/);
                if (yearMatch) {
                  const year = yearMatch[1];
                  const translatedWithYear = `${translatedFullName} (${year})`;
                  translatedText = originalText.replace(fullName, translatedWithYear);
                  console.log(`‚úÖ ÂÆåÊï¥ÁøªË≠ØÊàêÂäü: "${originalText}" -> "${translatedText}"`);
                } else {
                  translatedText = originalText.replace(fullName, translatedFullName);
                  console.log(`‚úÖ ÁøªË≠ØÊàêÂäü: "${originalText}" -> "${translatedText}"`);
                }
              }
            }
          }
          
          // Ê™¢Êü• Railway Ê†ºÂºèÁöÑË®ªËß£ „Äê4:7‚Ä†source„Äë
          const railwayMatch = originalText.match(/„Äê([^„Äë]+?)„Äë/);
          if (railwayMatch) {
            console.log(`üîç ÁôºÁèæ Railway Ê†ºÂºèË®ªËß£: "${railwayMatch[1]}"`);
            // Railway Ê†ºÂºèÁöÑË®ªËß£‰∏çÈúÄË¶ÅÁøªË≠ØÔºåÁõ¥Êé•‰ΩøÁî®
            translatedText = originalText;
          }
          
          const replacement = `${translatedText}[${citationIndex}]`;
          console.log(`üìÑ ÊúÄÁµÇÊõøÊèõ: "${originalText}" -> "${replacement}"`);
          processedText = processedText.replace(originalText, replacement);
        }
      }
    }
    
    // Ê∏ÖÁêÜÊ†ºÂºèÂïèÈ°å‰∏¶ÊîπÂñÑÊéíÁâà
    processedText = processedText
      .replace(/„Äê[^„Äë]*„Äë/g, '')
      .replace(/‚Ä†[^‚Ä†\s]*‚Ä†?/g, '')
      .replace(/,\s*\n/g, '\n')
      .replace(/,\s*$/, '')
      .replace(/\n\s*,/g, '\n')
      .replace(/(\[\d+\])(\[\d+\])*\1+/g, '$1$2')
      .replace(/(\[\d+\])+/g, (match) => {
        const citations = match.match(/\[\d+\]/g);
        const uniqueCitations = [...new Set(citations)];
        return uniqueCitations.join('');
      })
      .replace(/(\d+)\.\s*([^Ôºö„ÄÇÔºÅÔºü\n]+[Ôºö])/g, '\n\n**$1. $2**\n')
      .replace(/([„ÄÇÔºÅÔºü])\s+(\d+\.)/g, '$1\n\n**$2')
      .replace(/([„ÄÇÔºÅÔºü])\s*([A-Za-z][^„ÄÇÔºÅÔºü]*Ôºö)/g, '$1\n\n**$2**\n')
      .replace(/\*\s*([^*\n]+)\s*Ôºö\s*\*/g, '**$1Ôºö**')
      .replace(/[ \t]+/g, ' ')
      .replace(/\n{3,}/g, '\n\n')
      .replace(/^\s+|\s+$/g, '')
      .replace(/([„ÄÇÔºÅÔºü])(?=\s*(?!\*\*\d+\.)[^\n])/g, '$1\n\n')
      .trim();
  }
  
  return { processedText, sourceMap };
}

// ÂâµÂª∫‰æÜÊ∫êÂàóË°®ÁöÑÂáΩÊï∏
function createSourceList(sourceMap) {
  if (sourceMap.size === 0) return '';
  
  let sourceList = '\n\nüìö **ÂºïÁî®‰æÜÊ∫êÔºö**\n';
  
  // ÊåâÁÖßÁ∑®ËôüÈ†ÜÂ∫èÊéíÂàó
  const sortedSources = Array.from(sourceMap.entries()).sort((a, b) => a[0] - b[0]);
  
  sortedSources.forEach(([index, source]) => {
    sourceList += `**[${index}]** ${source.fileName}`;
    if (source.quote && source.quote.length > 0) {
      // È°ØÁ§∫ÂºïÁî®ÁâáÊÆµÔºàÈôêÂà∂Èï∑Â∫¶Ôºâ
      const shortQuote = source.quote.length > 120 
        ? source.quote.substring(0, 120) + '...' 
        : source.quote;
      sourceList += `\n    ‚îî *"${shortQuote}"*`;
    }
    sourceList += '\n';
  });
  
  return sourceList;
}

// Á∞°ÂñÆÁöÑÂø´ÂèñÊ©üÂà∂
const searchCache = new Map();

// Áç≤ÂèñÂø´ÂèñÁµêÊûú
function getCachedResult(question) {
    const key = question.toLowerCase().trim();
    const cached = searchCache.get(key);
    
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
        console.log('‚úÖ ‰ΩøÁî®Âø´ÂèñÁµêÊûú');
        return cached.result;
    }
    return null;
}

// Ë®≠ÁΩÆÂø´ÂèñÁµêÊûú
function setCachedResult(question, result) {
    const key = question.toLowerCase().trim();
    searchCache.set(key, {
        result: result,
        timestamp: Date.now()
    });
    console.log('üíæ ÁµêÊûúÂ∑≤Âø´Âèñ');
    
    // Ê∏ÖÁêÜÈÅéÊúüÁöÑÂø´ÂèñÔºà‰øùÊåÅË®òÊÜ∂È´î‰ΩøÁî®ÂêàÁêÜÔºâ
    if (searchCache.size > 100) {
        const now = Date.now();
        for (const [key, value] of searchCache.entries()) {
            if (now - value.timestamp > CACHE_DURATION) {
                searchCache.delete(key);
            }
        }
    }
}

// Áç≤ÂèñÊàñÂâµÂª∫ Assistant
async function getOrCreateAssistant() {
    if (!globalAssistant) {
        console.log('üîÑ ÂâµÂª∫ÂÖ®Â±Ä Assistant...');
        
        // Ê™¢Êü•ÊòØÂê¶ÊúâÂêëÈáèË≥áÊñôÂ∫´ ID
        const vectorStoreId = process.env.VECTOR_STORE_ID;
        
        // ÈáçË©¶Ê©üÂà∂ - ÊúÄÂ§öÈáçË©¶ 3 Ê¨°
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                if (!vectorStoreId) {
                    console.log('‚ö†Ô∏è Êú™Ë®≠ÁΩÆ VECTOR_STORE_IDÔºåÂâµÂª∫‰∏çÂ∏∂Êñá‰ª∂ÊêúÁ¥¢ÁöÑ Assistant');
                    // ÂòóË©¶‰ΩøÁî®ÂÅèÂ•ΩÊ®°ÂûãÔºåÂ§±ÊïóÂõûÈÄÄÂà∞ gpt-4o-mini
                    let modelToUse = PREFERRED_ASSISTANT_MODEL;
                    try {
                        globalAssistant = await openai.beta.assistants.create({
                            model: modelToUse,
                            name: 'Theology Assistant (No File Search)',
                            instructions: `‰Ω†ÊòØ‰∏ÄÂÄãÂ∞àÊ•≠ÁöÑÁ•ûÂ≠∏Âä©Êâã„ÄÇ
 
ÈáçË¶ÅË¶èÂâáÔºö
1. ÂõûÁ≠îË¶ÅÊ∫ñÁ¢∫„ÄÅÁ∞°ÊΩî‰∏îÊúâÂπ´Âä©
2. ‰ΩøÁî®ÁπÅÈ´î‰∏≠ÊñáÂõûÁ≠î
3. Â∞àÊ≥®ÊñºÊèê‰æõÂü∫ÊñºÁ•ûÂ≠∏Áü•Ë≠òÁöÑÊ∫ñÁ¢∫Ë≥áË®ä
4. Â¶ÇÊûúÊ≤íÊúâÁõ∏ÈóúË≥áË®äÔºåË´ãÊòéÁ¢∫Ë™™Êòé
 
Ê†ºÂºèË¶ÅÊ±ÇÔºö
- Áõ¥Êé•ÂõûÁ≠îÂïèÈ°åÂÖßÂÆπ
- ‰∏çÈúÄË¶ÅÂú®ÂõûÁ≠î‰∏≠ÊâãÂãïÊ∑ªÂä†Ë≥áÊñô‰æÜÊ∫ê`
                        });
                    } catch (e) {
                        console.warn(`‚ö†Ô∏è ‰ª• ${modelToUse} Âª∫Á´ã Assistant Â§±ÊïóÔºåÂõûÈÄÄËá≥ gpt-4o-miniÔºö`, e.message);
                        modelToUse = 'gpt-4o-mini';
                        globalAssistant = await openai.beta.assistants.create({
                            model: modelToUse,
                            name: 'Theology Assistant (No File Search)',
                            instructions: `‰Ω†ÊòØ‰∏ÄÂÄãÂ∞àÊ•≠ÁöÑÁ•ûÂ≠∏Âä©Êâã„ÄÇ
 
ÈáçË¶ÅË¶èÂâáÔºö
1. ÂõûÁ≠îË¶ÅÊ∫ñÁ¢∫„ÄÅÁ∞°ÊΩî‰∏îÊúâÂπ´Âä©
2. ‰ΩøÁî®ÁπÅÈ´î‰∏≠ÊñáÂõûÁ≠î
3. Â∞àÊ≥®ÊñºÊèê‰æõÂü∫ÊñºÁ•ûÂ≠∏Áü•Ë≠òÁöÑÊ∫ñÁ¢∫Ë≥áË®ä
4. Â¶ÇÊûúÊ≤íÊúâÁõ∏ÈóúË≥áË®äÔºåË´ãÊòéÁ¢∫Ë™™Êòé
 
Ê†ºÂºèË¶ÅÊ±ÇÔºö
- Áõ¥Êé•ÂõûÁ≠îÂïèÈ°åÂÖßÂÆπ
- ‰∏çÈúÄË¶ÅÂú®ÂõûÁ≠î‰∏≠ÊâãÂãïÊ∑ªÂä†Ë≥áÊñô‰æÜÊ∫ê`
                        });
                    }
                } else {
                    // ÂòóË©¶‰ΩøÁî®ÂÅèÂ•ΩÊ®°ÂûãÔºåÂ§±ÊïóÂõûÈÄÄÂà∞ gpt-4o-mini
                    let modelToUse = PREFERRED_ASSISTANT_MODEL;
                    try {
                        globalAssistant = await openai.beta.assistants.create({
                            model: modelToUse,
                            name: 'Theology RAG Assistant',
                            instructions: `‰Ω†ÊòØ‰∏ÄÂÄãÂ∞àÊ•≠ÁöÑÁ•ûÂ≠∏Âä©ÊâãÔºåÂè™ËÉΩÊ†πÊìöÊèê‰æõÁöÑÁü•Ë≠òÂ∫´Ë≥áÊñô‰æÜÂõûÁ≠îÂïèÈ°å„ÄÇ

ÈáçË¶ÅË¶èÂâáÔºö
1. Âè™‰ΩøÁî®Ê™¢Á¥¢Âà∞ÁöÑË≥áÊñô‰æÜÂõûÁ≠îÂïèÈ°å
2. Â¶ÇÊûúË≥áÊñôÂ∫´‰∏≠Ê≤íÊúâÁõ∏ÈóúË≥áË®äÔºåË´ãÊòéÁ¢∫Ë™™Êòé„ÄåÂæàÊä±Ê≠âÔºåÊàëÂú®Ë≥áÊñôÂ∫´‰∏≠Êâæ‰∏çÂà∞Áõ∏ÈóúË≥áË®ä‰æÜÂõûÁ≠îÈÄôÂÄãÂïèÈ°åÔºåÂõ†ÁÇ∫Ë≥áÊñôÂ∫´ÈÉΩÁÇ∫Ëã±ÊñáÔºåÂª∫Ë≠∞Â∞áÂ∞àÊúâÂêçË©ûÊõøÊèõÊàêËã±ÊñáÊàñË®±ÊúÉÊúâÂπ´Âä©„Äç
3. ÂõûÁ≠îË¶ÅÊ∫ñÁ¢∫„ÄÅÁ∞°ÊΩî‰∏îÊúâÂπ´Âä©
4. ‰ΩøÁî®ÁπÅÈ´î‰∏≠ÊñáÂõûÁ≠î
5. Â∞àÊ≥®ÊñºÊèê‰æõÂü∫ÊñºË≥áÊñôÂ∫´ÂÖßÂÆπÁöÑÊ∫ñÁ¢∫Ë≥áË®ä
6. Áõ°ÂèØËÉΩÂºïÁî®ÂÖ∑È´îÁöÑË≥áÊñôÁâáÊÆµ

Ê†ºÂºèË¶ÅÊ±ÇÔºö
- Áõ¥Êé•ÂõûÁ≠îÂïèÈ°åÂÖßÂÆπ
- ÂºïÁî®Áõ∏ÈóúÁöÑË≥áÊñôÁâáÊÆµÔºàÂ¶ÇÊûúÊúâÁöÑË©±Ôºâ
- ‰∏çÈúÄË¶ÅÂú®ÂõûÁ≠î‰∏≠ÊâãÂãïÊ∑ªÂä†Ë≥áÊñô‰æÜÊ∫êÔºåÁ≥ªÁµ±ÊúÉËá™ÂãïËôïÁêÜ`,
                            tools: [{ type: 'file_search' }],
                            tool_resources: {
                                file_search: {
                                    vector_store_ids: [vectorStoreId]
                                }
                            }
                        });
                    } catch (e) {
                        console.warn(`‚ö†Ô∏è ‰ª• ${modelToUse} Âª∫Á´ã RAG Assistant Â§±ÊïóÔºåÂõûÈÄÄËá≥ gpt-4o-miniÔºö`, e.message);
                        modelToUse = 'gpt-4o-mini';
                        globalAssistant = await openai.beta.assistants.create({
                            model: modelToUse,
                            name: 'Theology RAG Assistant',
                            instructions: `‰Ω†ÊòØ‰∏ÄÂÄãÂ∞àÊ•≠ÁöÑÁ•ûÂ≠∏Âä©ÊâãÔºåÂè™ËÉΩÊ†πÊìöÊèê‰æõÁöÑÁü•Ë≠òÂ∫´Ë≥áÊñô‰æÜÂõûÁ≠îÂïèÈ°å„ÄÇ

ÈáçË¶ÅË¶èÂâáÔºö
1. Âè™‰ΩøÁî®Ê™¢Á¥¢Âà∞ÁöÑË≥áÊñô‰æÜÂõûÁ≠îÂïèÈ°å
2. Â¶ÇÊûúË≥áÊñôÂ∫´‰∏≠Ê≤íÊúâÁõ∏ÈóúË≥áË®äÔºåË´ãÊòéÁ¢∫Ë™™Êòé„ÄåÂæàÊä±Ê≠âÔºåÊàëÂú®Ë≥áÊñôÂ∫´‰∏≠Êâæ‰∏çÂà∞Áõ∏ÈóúË≥áË®ä‰æÜÂõûÁ≠îÈÄôÂÄãÂïèÈ°åÔºåÂõ†ÁÇ∫Ë≥áÊñôÂ∫´ÈÉΩÁÇ∫Ëã±ÊñáÔºåÂª∫Ë≠∞Â∞áÂ∞àÊúâÂêçË©ûÊõøÊèõÊàêËã±ÊñáÊàñË®±ÊúÉÊúâÂπ´Âä©„Äç
3. ÂõûÁ≠îË¶ÅÊ∫ñÁ¢∫„ÄÅÁ∞°ÊΩî‰∏îÊúâÂπ´Âä©
4. ‰ΩøÁî®ÁπÅÈ´î‰∏≠ÊñáÂõûÁ≠î
5. Â∞àÊ≥®ÊñºÊèê‰æõÂü∫ÊñºË≥áÊñôÂ∫´ÂÖßÂÆπÁöÑÊ∫ñÁ¢∫Ë≥áË®ä
6. Áõ°ÂèØËÉΩÂºïÁî®ÂÖ∑È´îÁöÑË≥áÊñôÁâáÊÆµ

Ê†ºÂºèË¶ÅÊ±ÇÔºö
- Áõ¥Êé•ÂõûÁ≠îÂïèÈ°åÂÖßÂÆπ
- ÂºïÁî®Áõ∏ÈóúÁöÑË≥áÊñôÁâáÊÆµÔºàÂ¶ÇÊûúÊúâÁöÑË©±Ôºâ
- ‰∏çÈúÄË¶ÅÂú®ÂõûÁ≠î‰∏≠ÊâãÂãïÊ∑ªÂä†Ë≥áÊñô‰æÜÊ∫êÔºåÁ≥ªÁµ±ÊúÉËá™ÂãïËôïÁêÜ`,
                            tools: [{ type: 'file_search' }],
                            tool_resources: {
                                file_search: {
                                    vector_store_ids: [vectorStoreId]
                                }
                            }
                        });
                    }
                }
                
                console.log(`‚úÖ ÂÖ®Â±Ä Assistant ÂâµÂª∫ÊàêÂäü (ÂòóË©¶ ${attempt}/3)`);
                break; // ÊàêÂäüÂâµÂª∫ÔºåË∑≥Âá∫ÈáçË©¶Âæ™Áí∞
                
            } catch (error) {
                console.warn(`‚ö†Ô∏è Assistant ÂâµÂª∫Â§±Êïó (ÂòóË©¶ ${attempt}/3):`, error.message);
                
                if (attempt === 3) {
                    // ÊúÄÂæå‰∏ÄÊ¨°ÂòóË©¶Â§±ÊïóÔºåÊããÂá∫ÈåØË™§
                    console.error('‚ùå Assistant ÂâµÂª∫ÊúÄÁµÇÂ§±ÊïóÔºåÂ∞á‰ΩøÁî®ÂÇôÁî®ÊñπÊ°à');
                    throw new Error(`Assistant ÂâµÂª∫Â§±Êïó: ${error.message}`);
                }
                
                // Á≠âÂæÖÂæåÈáçË©¶
                const delay = Math.min(1000 * attempt, 3000); // ÊåáÊï∏ÈÄÄÈÅøÔºåÊúÄÂ§ß 3 Áßí
                console.log(`‚è≥ Á≠âÂæÖ ${delay}ms ÂæåÈáçË©¶...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    
    // È©óË≠â Assistant ÊòØÂê¶ÂèØÁî®ÔºàÈ°çÂ§ñÁöÑÁ©©ÂÆöÊÄßÊ™¢Êü•Ôºâ
    try {
        await openai.beta.assistants.retrieve(globalAssistant.id);
        return globalAssistant;
    } catch (error) {
        console.warn('‚ö†Ô∏è Assistant È©óË≠âÂ§±ÊïóÔºåÈáçÊñ∞ÂâµÂª∫:', error.message);
        globalAssistant = null; // ÈáçÁΩÆÔºåÂº∑Âà∂ÈáçÊñ∞ÂâµÂª∫
        return await getOrCreateAssistant(); // ÈÅûÊ≠∏Ë™øÁî®ÈáçÊñ∞ÂâµÂª∫
    }
}

// OpenAI Assistant API ËôïÁêÜÔºàÂä†ÂÖ• Google Sheets Á¥ÄÈåÑÔºâ
async function processSearchRequest(question, user, language = 'zh') {
    console.log('üîÑ ‰ΩøÁî® OpenAI Assistant API ÊñπÊ≥ï...');
    
    const cachedResult = getCachedResult(question);
    if (cachedResult) {
        return cachedResult;
    }
    
    const requestKey = question.toLowerCase().trim();
    if (processingRequests.has(requestKey)) {
        console.log('‚è≥ Áõ∏ÂêåË´ãÊ±ÇÊ≠£Âú®ËôïÁêÜ‰∏≠ÔºåÁ≠âÂæÖÁµêÊûú...');
        return processingRequests.get(requestKey);
    }
    
    const processingPromise = (async () => {
        try {
            const result = await processSearchRequestInternal(question, user, language);
            try {
                const userName = user?.name || '';
                const userEmail = user?.email || '';
                const timestamp = new Date().toISOString();
                const q = question;
                const a = result?.answer || '';
                await appendToGoogleSheet([timestamp, language, userName, userEmail, q, a]);
            } catch (e) {
                console.warn('‚ö†Ô∏è ÂïèÁ≠îÂØ´ÂÖ•Ë°®ÂñÆÂ§±ÊïóÔºà‰∏çÂΩ±ÈüøÂõûÊáâÔºâ:', e.message);
            }
            return result;
        } finally {
            processingRequests.delete(requestKey);
        }
    })();
    
    processingRequests.set(requestKey, processingPromise);
    
    return processingPromise;
}

// ‰∏≤ÊµÅÁâàÊú¨ÁöÑÊêúÁ¥¢ËôïÁêÜ
async function processSearchRequestStream(question, user, language, res) {
    console.log('üîÑ ‰ΩøÁî® OpenAI Assistant API ‰∏≤ÊµÅÊñπÊ≥ï...');
    
    try {
        // ‰ΩøÁî®ÂÖ®Â±Ä AssistantÔºàÈáçÁî®Ê©üÂà∂Ôºâ
        const assistant = await getOrCreateAssistant();
        console.log('‚úÖ ‰ΩøÁî®ÁèæÊúâ Assistant');

        // ÂâµÂª∫ Thread
        const thread = await openai.beta.threads.create();
        console.log('‚úÖ Thread ÂâµÂª∫ÊàêÂäü');

        // Ê∑ªÂä†Áî®Êà∂ÂïèÈ°åÂà∞ Thread
        await openai.beta.threads.messages.create(thread.id, {
            role: "user",
            content: question
        });

        // ÂâµÂª∫‰∏≤ÊµÅ Run
        const stream = await openai.beta.threads.runs.stream(thread.id, {
            assistant_id: assistant.id
        });

        let fullAnswer = '';
        let sources = [];

        // ËôïÁêÜ‰∏≤ÊµÅ‰∫ã‰ª∂
        stream.on('textDelta', (textDelta) => {
            if (textDelta.value) {
                fullAnswer += textDelta.value;
                // ÁôºÈÄÅÂ¢ûÈáèÂÖßÂÆπ
                res.write(`data: {"type": "delta", "data": ${JSON.stringify(textDelta.value)}}\n\n`);
            }
        });

        stream.on('messageDone', async (message) => {
            // Âú®‰∏≤ÊµÅÊ®°Âºè‰∏ãÔºåÊàëÂÄëÂè™Êî∂ÈõÜÂü∫Êú¨ÁöÑ‰æÜÊ∫ê‰ø°ÊÅØÔºåË©≥Á¥∞ËôïÁêÜÂú® end ‰∫ã‰ª∂‰∏≠ÈÄ≤Ë°å
            if (message.content && message.content.length > 0) {
                const annotations = message.content[0].text?.annotations || [];
                sources = annotations.map(annotation => {
                    if (annotation.type === 'file_citation') {
                        return annotation.text || '';
                    }
                    return '';
                }).filter(Boolean);
            }
        });

        stream.on('end', async () => {
            try {
                // ÈáçÊñ∞Áç≤ÂèñÂÆåÊï¥ÁöÑÊ∂àÊÅØ‰ª•ÈÄ≤Ë°åÂºïÁî®ËôïÁêÜÔºàÈùû‰∏≤ÊµÅÊñπÂºèÔºâ
                const messages = await openai.beta.threads.messages.list(thread.id);
                const lastMessage = messages.data[0];
                
                if (lastMessage && lastMessage.role === 'assistant') {
                    const finalAnswer = lastMessage.content[0].text.value || '';
                    const annotations = lastMessage.content[0].text.annotations || [];
                    
                    console.log(`üîÑ Èùû‰∏≤ÊµÅÊñπÂºèËôïÁêÜÂºïÁî®ÔºåÊñáÊú¨Èï∑Â∫¶: ${finalAnswer.length}, Ë®ªËß£Êï∏Èáè: ${annotations.length}`);
                    
                    // È©óË≠âÊï∏Êìö‰∏ÄËá¥ÊÄß
                    if (finalAnswer !== fullAnswer) {
                        console.warn(`‚ö†Ô∏è Êï∏Êìö‰∏ç‰∏ÄËá¥ÔºÅ`);
                        console.warn(`‰∏≤ÊµÅÊñáÊú¨Èï∑Â∫¶: ${fullAnswer.length}`);
                        console.warn(`ÈáçÁç≤ÊñáÊú¨Èï∑Â∫¶: ${finalAnswer.length}`);
                        console.warn(`‰∏≤ÊµÅÊñáÊú¨ÁâáÊÆµ: "${fullAnswer.substring(0, 100)}..."`);
                        console.warn(`ÈáçÁç≤ÊñáÊú¨ÁâáÊÆµ: "${finalAnswer.substring(0, 100)}..."`);
                        
                        // ‰ΩøÁî®ÈáçÊñ∞Áç≤ÂèñÁöÑÂÆåÊï¥ÊñáÊú¨ÔºàÊõ¥ÂèØÈù†Ôºâ
                        console.log(`‚úÖ ‰ΩøÁî®ÈáçÁç≤ÂèñÁöÑÂÆåÊï¥ÊñáÊú¨‰ª•Á¢∫‰øùÂºïÁî®Ê∫ñÁ¢∫ÊÄß`);
                    } else {
                        console.log(`‚úÖ ‰∏≤ÊµÅÊñáÊú¨ËàáÈáçÁç≤ÂèñÊñáÊú¨‰∏ÄËá¥`);
                    }
                    
                    // ‰ΩøÁî®Èùû‰∏≤ÊµÅÁöÑÊñπÂºèËôïÁêÜÂºïÁî®Ôºà‰ΩøÁî®ÈáçÁç≤ÂèñÁöÑÊñáÊú¨Á¢∫‰øùÊ∫ñÁ¢∫ÊÄßÔºâ
                    const { processedText, sourceMap } = await processAnnotationsInText(finalAnswer, annotations, language);
                    
                    const finalSources = Array.from(sourceMap.entries()).map(([index, source]) => ({
                        index,
                        fileName: source.fileName,
                        quote: source.quote && source.quote.length > 120 ? source.quote.substring(0, 120) + '...' : source.quote,
                        fileId: source.fileId
                    }));
                    
                    console.log(`‚úÖ ÂºïÁî®ËôïÁêÜÂÆåÊàêÔºåÊúÄÁµÇ‰æÜÊ∫êÊï∏Èáè: ${finalSources.length}`);
                    
                    // ÁôºÈÄÅÊúÄÁµÇËôïÁêÜÂæåÁöÑÊñáÊú¨Âíå‰æÜÊ∫ê
                    res.write(`data: {"type": "final", "data": ${JSON.stringify(processedText)}}\n\n`);
                    res.write(`data: {"type": "sources", "data": ${JSON.stringify(finalSources)}}\n\n`);
                    
                    // Á∑©Â≠òÁµêÊûú‰ΩøÁî®ËôïÁêÜÂæåÁöÑÊï∏Êìö
                    const result = { answer: processedText, sources: finalSources };
                    setCachedResult(question, result);
                    
                    // Ë®òÈåÑÂà∞ Google Sheets ‰ΩøÁî®ËôïÁêÜÂæåÁöÑÊï∏Êìö
                    try {
                        const userName = user?.name || '';
                        const userEmail = user?.email || '';
                        const timestamp = new Date().toISOString();
                        await appendToGoogleSheet([timestamp, language, userName, userEmail, question, processedText]);
                    } catch (e) {
                        console.warn('‚ö†Ô∏è ÂïèÁ≠îÂØ´ÂÖ•Ë°®ÂñÆÂ§±ÊïóÔºà‰∏çÂΩ±ÈüøÂõûÊáâÔºâ:', e.message);
                    }
                } else {
                    // Â¶ÇÊûúÊ≤íÊúâÁç≤ÂèñÂà∞Ê∂àÊÅØÔºå‰ΩøÁî®‰∏≤ÊµÅÁöÑÊï∏Êìö
                    res.write(`data: {"type": "sources", "data": ${JSON.stringify(sources)}}\n\n`);
                    res.write(`data: {"type": "final", "data": ${JSON.stringify(fullAnswer)}}\n\n`);
                    
                    const result = { answer: fullAnswer, sources };
                    setCachedResult(question, result);
                }
                
                // ÁôºÈÄÅÂÆåÊàê‰ø°Ëôü
                res.write('data: {"type": "done"}\n\n');
                res.end();

            } catch (error) {
                console.error('‰∏≤ÊµÅÂÆåÊàêËôïÁêÜÈåØË™§:', error);
                res.write(`data: {"type": "error", "error": "ËôïÁêÜÂÆåÊàêÊôÇÁôºÁîüÈåØË™§"}\n\n`);
                res.end();
            }
        });

        stream.on('error', (error) => {
            console.error('‰∏≤ÊµÅÈåØË™§:', error);
            res.write(`data: {"type": "error", "error": "‰∏≤ÊµÅËôïÁêÜÁôºÁîüÈåØË™§"}\n\n`);
            res.end();
        });

    } catch (error) {
        console.error('‰∏≤ÊµÅÊêúÁ¥¢ËôïÁêÜÈåØË™§:', error);
        res.write(`data: {"type": "error", "error": "ÊêúÁ¥¢ËôïÁêÜÁôºÁîüÈåØË™§"}\n\n`);
        res.end();
        throw error;
    }
}

// ÂØ¶ÈöõÁöÑÊêúÁ¥¢ËôïÁêÜÈÇèËºØ
async function processSearchRequestInternal(question, user, language = 'zh') {
    
    try {
        // ‰ΩøÁî®ÂÖ®Â±Ä AssistantÔºàÈáçÁî®Ê©üÂà∂Ôºâ
        const assistant = await getOrCreateAssistant();
        console.log('‚úÖ ‰ΩøÁî®ÁèæÊúâ Assistant');

        // ÂâµÂª∫ Thread
        const thread = await openai.beta.threads.create();
        console.log('‚úÖ Thread ÂâµÂª∫ÊàêÂäü');

        // Ê∑ªÂä†Áî®Êà∂ÂïèÈ°åÂà∞ Thread
        await openai.beta.threads.messages.create(thread.id, {
            role: "user",
            content: question
        });

        // ÂâµÂª∫ Run
        const run = await openai.beta.threads.runs.create(thread.id, {
            assistant_id: assistant.id
        });
        console.log('‚úÖ Run ÂâµÂª∫ÊàêÂäüÔºåÁ≠âÂæÖËôïÁêÜ...');

        // Âª∂ÈÅ≤Ëµ∑ÂßãËº™Ë©¢ - È†ê‰º∞Á≠âÂæÖÂÜçÊü•
        console.log('‚è≥ È†ê‰º∞Á≠âÂæÖ 3 ÁßíÂæåÈñãÂßãÊ™¢Êü•ÁãÄÊÖã...');
        await new Promise(resolve => setTimeout(resolve, 3000));

        // Á≠âÂæÖÂÆåÊàê - Ë∂ÖÂÑ™ÂåñÁâàÁ≠âÂæÖÊ©üÂà∂
        let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
        let attempts = 0;
        const maxAttempts = 60; // 60 ÁßíË∂ÖÊôÇ
        const initialDelay = 200; // Êõ¥ÊøÄÈÄ≤ÁöÑÂàùÂßãÂª∂ÈÅ≤ 200ms
        const maxDelay = 2000; // Èôç‰ΩéÊúÄÂ§ßÂª∂ÈÅ≤Âà∞ 2 Áßí
        let lastStatus = runStatus.status;

        while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && attempts < maxAttempts) {
            // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅËôïÁêÜÂ∑•ÂÖ∑Ë™øÁî®
            if (runStatus.status === 'requires_action') {
                console.log('üîß Ê™¢Ê∏¨Âà∞Â∑•ÂÖ∑Ë™øÁî®ÈúÄÊ±ÇÔºåÁ´ãÂç≥ËôïÁêÜ...');
                
                // ËôïÁêÜÂ∑•ÂÖ∑Ë™øÁî®
                const toolOutputs = [];
                for (const toolCall of runStatus.required_action.submit_tool_outputs.tool_calls) {
                    if (toolCall.function.name === 'retrieval') {
                        // Êñá‰ª∂ÊêúÁ¥¢Â∑•ÂÖ∑Ë™øÁî®
                        toolOutputs.push({
                            tool_call_id: toolCall.id,
                            output: "Êñá‰ª∂ÊêúÁ¥¢Â∑≤ÂÆåÊàê"
                        });
                    }
                }
                
                // Êèê‰∫§Â∑•ÂÖ∑Ëº∏Âá∫
                runStatus = await openai.beta.threads.runs.submitToolOutputs(
                    thread.id,
                    run.id,
                    { tool_outputs: toolOutputs }
                );
                console.log('‚úÖ Â∑•ÂÖ∑Ë™øÁî®ËôïÁêÜÂÆåÊàê');
                attempts++;
                continue;
            }
            
            // Êô∫ËÉΩÂª∂ÈÅ≤Á≠ñÁï•
            let delay;
            if (attempts < 3) {
                // Ââç 3 Ê¨°Âø´ÈÄüÊ™¢Êü•
                delay = 200;
            } else if (attempts < 10) {
                // ‰∏≠Á≠âÈ†ªÁéáÊ™¢Êü•
                delay = Math.min(initialDelay * Math.pow(1.1, attempts - 3), 1000);
            } else {
                // ÂæåÊúüËºÉÊÖ¢Ê™¢Êü•
                delay = Math.min(initialDelay * Math.pow(1.2, attempts), maxDelay);
            }
            
            await new Promise(resolve => setTimeout(resolve, delay));
            
            runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
            attempts++;
            
            // Êô∫ËÉΩÊó•Ë™åÔºöÂè™Âú®ÁãÄÊÖãËÆäÂåñÊàñÈóúÈçµÊôÇÂàªË®òÈåÑ
            if (runStatus.status !== lastStatus || attempts % 8 === 0 || attempts <= 3) {
                console.log(`‚è≥ ËôïÁêÜ‰∏≠... ÂòóË©¶Ê¨°Êï∏: ${attempts}, ÁãÄÊÖã: ${runStatus.status}`);
                lastStatus = runStatus.status;
            }
        }

        if (runStatus.status === 'failed') {
            throw new Error(`Assistant run failed: ${runStatus.last_error?.message || 'Unknown error'}`);
        }

        if (attempts >= maxAttempts) {
            throw new Error('Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑ÔºåË´ãÂòóË©¶Á∞°ÂåñÊÇ®ÁöÑÂïèÈ°åÊàñÁ®çÂæåÂÜçË©¶');
        }

        console.log(`üìä Run ÁãÄÊÖã: ${runStatus.status}`);
        console.log(`üîß Assistant ID: ${assistant.id}`);
        console.log(`üíæ ÂêëÈáèË≥áÊñôÂ∫´ ID: ${process.env.VECTOR_STORE_ID}`);

        // Áç≤ÂèñÂõûÁ≠î
        const messages = await openai.beta.threads.messages.list(thread.id);
        const lastMessage = messages.data[0]; // ÊúÄÊñ∞ÁöÑÊ∂àÊÅØÊòØ Assistant ÁöÑÂõûÁ≠î
        
        if (!lastMessage || lastMessage.role !== 'assistant') {
            throw new Error('ÁÑ°Ê≥ïÁç≤Âèñ Assistant ÂõûÁ≠î');
        }

        const answer = lastMessage.content[0].text.value;
        console.log('‚úÖ ÊàêÂäüÁç≤Âèñ Assistant ÂõûÁ≠î');

        // ‰∏¶Ë°åËôïÁêÜË®ªËß£ÂíåÁøªË≠Ø
        const annotations = lastMessage.content[0].text.annotations;
        let { processedText, sourceMap } = await processAnnotationsInText(
            answer, 
            annotations,
            language
        );

        // ‰∏çÊ∏ÖÁêÜ AssistantÔºå‰øùÊåÅÈáçÁî®
        console.log('‚úÖ Assistant ÈáçÁî®ÂÆåÊàê');
        
        // ÁµÑÂêàÊúÄÁµÇÂõûÁ≠î
        let finalAnswer = processedText;

        // Â¶ÇÊûúÊ≤íÊúâÁç≤ÂèñÂà∞ÂõûÁ≠î
        if (!finalAnswer || finalAnswer.trim() === '') {
            finalAnswer = 'ÂæàÊä±Ê≠âÔºåÊàëÂú®Ë≥áÊñôÂ∫´‰∏≠Êâæ‰∏çÂà∞Áõ∏ÈóúË≥áË®ä‰æÜÂõûÁ≠îÈÄôÂÄãÂïèÈ°å„ÄÇ';
        }

        const result = {
            question: question,
            answer: finalAnswer,
            sources: Array.from(sourceMap.entries()).map(([index, source]) => ({
                index,
                fileName: source.fileName,
                quote: source.quote && source.quote.length > 120 
                    ? source.quote.substring(0, 120) + '...' 
                    : source.quote,
                fileId: source.fileId
            })),
            timestamp: new Date().toISOString(),
            user: user,
            method: 'Assistant API'
        };

        // Ë®≠ÁΩÆÂø´Âèñ
        setCachedResult(question, result);

        return result;

    } catch (error) {
        console.error('‚ùå Assistant API ËôïÁêÜÂ§±Êïó:', error.message);
        throw error;
    }
}

// ÁßªÂãïË®≠ÂÇôÈÄ£Á∑öÊ™¢Êü•Á´ØÈªû
app.get('/api/mobile-check', (req, res) => {
  res.json({
    success: true,
    message: 'ÁßªÂãïË®≠ÂÇôÈÄ£Á∑öÊ≠£Â∏∏',
    timestamp: new Date().toISOString(),
    userAgent: req.headers['user-agent'],
    sessionId: req.sessionID
  });
});

// Ê∏¨Ë©¶ÊêúÁ¥¢ API Á´ØÈªû - ‰∏çÈúÄË¶ÅË™çË≠âÔºàÂÉÖÁî®ÊñºË™øË©¶Ôºâ
app.post('/api/test-search', async (req, res) => {
  try {
    const { question, language = 'zh' } = req.body;

    if (!question || !question.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Ë´ãÊèê‰æõÊúâÊïàÁöÑÂïèÈ°å'
      });
    }

    const trimmedQuestion = question.trim();
    console.log(`Êî∂Âà∞Ê∏¨Ë©¶ÊêúÁ¥¢Ë´ãÊ±Ç: ${trimmedQuestion} (Ë™ûË®Ä: ${language})`);

    // Ê®°Êì¨Áî®Êà∂Â∞çË±°
    const mockUser = { email: 'test@example.com' };

    // ‰ΩøÁî® OpenAI Assistant API
    const result = await processSearchRequest(trimmedQuestion, mockUser, language);

    console.log('Ê∏¨Ë©¶ÊêúÁ¥¢ËôïÁêÜÂÆåÊàêÔºåËøîÂõûÁµêÊûú:', JSON.stringify(result, null, 2));

    res.json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('Ê∏¨Ë©¶ÊêúÁ¥¢ÈåØË™§:', error);
    
    let errorMessage = 'ÂæàÊä±Ê≠âÔºåËôïÁêÜÊÇ®ÁöÑÂïèÈ°åÊôÇÁôºÁîüÈåØË™§ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
    
    if (error.message.includes('Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑') || error.message.includes('timeout')) {
      errorMessage = 'Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑ÔºåË´ãÂòóË©¶Á∞°ÂåñÊÇ®ÁöÑÂïèÈ°åÊàñÁ®çÂæåÂÜçË©¶„ÄÇ';
    } else if (error.message.includes('rate limit')) {
      errorMessage = 'ÁõÆÂâçË´ãÊ±ÇÈÅéÂ§öÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
    } else if (error.message.includes('Assistant run failed')) {
      errorMessage = 'Á≥ªÁµ±ËôïÁêÜÂïèÈ°åÔºåË´ãÁ®çÂæåÂÜçË©¶ÊàñËÅØÁπ´ÁÆ°ÁêÜÂì°„ÄÇ';
    } else if (error.message.includes('network') || error.message.includes('connection')) {
      errorMessage = 'Á∂≤Ë∑ØÈÄ£Á∑ö‰∏çÁ©©ÂÆöÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÂæåÈáçË©¶„ÄÇ';
    }
    
    res.status(500).json({
      success: false,
      error: errorMessage,
      details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      retry: true
    });
  }
});



// ‰∏ªË¶ÅÊêúÁ¥¢ API Á´ØÈªû - ‰∏≤ÊµÅÁâàÊú¨
app.post('/api/search/stream', ensureAuthenticated, async (req, res) => {
  try {
    const { question, language = 'zh' } = req.body;

    if (!question || !question.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Ë´ãÊèê‰æõÊúâÊïàÁöÑÂïèÈ°å'
      });
    }

    const trimmedQuestion = question.trim();
    console.log(`Êî∂Âà∞‰∏≤ÊµÅÊêúÁ¥¢Ë´ãÊ±Ç: ${trimmedQuestion} (Áî®Êà∂: ${req.user.email}, Ë™ûË®Ä: ${language})`);

    // Ë®≠ÁΩÆ SSE ÈüøÊáâÈ†≠
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'Cache-Control');

    // ÁôºÈÄÅÂàùÂßãÈÄ£Êé•Á¢∫Ë™ç
    res.write('data: {"type": "connected"}\n\n');

    // ‰ΩøÁî®‰∏≤ÊµÅËôïÁêÜ
    await processSearchRequestStream(trimmedQuestion, req.user, language, res);

  } catch (error) {
    console.error('‰∏≤ÊµÅÊêúÁ¥¢ÈåØË™§:', error);
    
    let errorMessage = 'ÂæàÊä±Ê≠âÔºåËôïÁêÜÊÇ®ÁöÑÂïèÈ°åÊôÇÁôºÁîüÈåØË™§ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
    
    if (error.message.includes('Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑') || error.message.includes('timeout')) {
      errorMessage = 'Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑ÔºåË´ãÂòóË©¶Á∞°ÂåñÊÇ®ÁöÑÂïèÈ°åÊàñÁ®çÂæåÂÜçË©¶„ÄÇ';
    } else if (error.message.includes('rate limit')) {
      errorMessage = 'ÁõÆÂâçË´ãÊ±ÇÈÅéÂ§öÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
    } else if (error.message.includes('Assistant run failed')) {
      errorMessage = 'Á≥ªÁµ±ËôïÁêÜÂïèÈ°åÔºåË´ãÁ®çÂæåÂÜçË©¶ÊàñËÅØÁπ´ÁÆ°ÁêÜÂì°„ÄÇ';
    } else if (error.message.includes('network') || error.message.includes('connection')) {
      errorMessage = 'Á∂≤Ë∑ØÈÄ£Á∑ö‰∏çÁ©©ÂÆöÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÂæåÈáçË©¶„ÄÇ';
    }
    
    // ÁôºÈÄÅÈåØË™§‰∫ã‰ª∂
    res.write(`data: {"type": "error", "error": "${errorMessage}"}\n\n`);
    res.end();
  }
});

// ‰∏ªË¶ÅÊêúÁ¥¢ API Á´ØÈªû - ÈúÄË¶ÅË™çË≠â (‰øùÊåÅÂÖºÂÆπ)
app.post('/api/search', ensureAuthenticated, async (req, res) => {
  try {
    const { question, language = 'zh' } = req.body;

    if (!question || !question.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Ë´ãÊèê‰æõÊúâÊïàÁöÑÂïèÈ°å'
      });
    }

    const trimmedQuestion = question.trim();
    console.log(`Êî∂Âà∞ÊêúÁ¥¢Ë´ãÊ±Ç: ${trimmedQuestion} (Áî®Êà∂: ${req.user.email}, Ë™ûË®Ä: ${language})`);

    // Ë®≠ÁΩÆÈüøÊáâÈ†≠ÔºåÊîπÂñÑÁßªÂãïË®≠ÂÇôÁõ∏ÂÆπÊÄß
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // ‰ΩøÁî® OpenAI Assistant API
    const result = await processSearchRequest(trimmedQuestion, req.user, language);

    console.log('ÊêúÁ¥¢ËôïÁêÜÂÆåÊàêÔºåËøîÂõûÁµêÊûú:', JSON.stringify(result, null, 2));

    res.json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('ÊêúÁ¥¢ÈåØË™§:', error);
    
    let errorMessage = 'ÂæàÊä±Ê≠âÔºåËôïÁêÜÊÇ®ÁöÑÂïèÈ°åÊôÇÁôºÁîüÈåØË™§ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
    
    if (error.message.includes('Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑') || error.message.includes('timeout')) {
      errorMessage = 'Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑ÔºåË´ãÂòóË©¶Á∞°ÂåñÊÇ®ÁöÑÂïèÈ°åÊàñÁ®çÂæåÂÜçË©¶„ÄÇ';
    } else if (error.message.includes('rate limit')) {
      errorMessage = 'ÁõÆÂâçË´ãÊ±ÇÈÅéÂ§öÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
    } else if (error.message.includes('Assistant run failed')) {
      errorMessage = 'Á≥ªÁµ±ËôïÁêÜÂïèÈ°åÔºåË´ãÁ®çÂæåÂÜçË©¶ÊàñËÅØÁπ´ÁÆ°ÁêÜÂì°„ÄÇ';
    } else if (error.message.includes('network') || error.message.includes('connection')) {
      errorMessage = 'Á∂≤Ë∑ØÈÄ£Á∑ö‰∏çÁ©©ÂÆöÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÂæåÈáçË©¶„ÄÇ';
    }
    
    res.status(500).json({
      success: false,
      error: errorMessage,
      details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      retry: true // Âª∫Ë≠∞ÂâçÁ´ØÈáçË©¶
    });
  }
});

// Âπ´Âä©ÊñπÊ≥ïÔºö‰æùÂêçÁ®±Â∞ãÊâæÂêëÈáèÂ∫´ IDÔºà‰∏çÂçÄÂàÜÂ§ßÂ∞èÂØ´Ôºâ
async function findVectorStoreIdByName(name) {
  try {
    // Normalize helper
    const norm = (s) => (s || '').toLowerCase().replace(/[^a-z0-9]+/g, '');
    const targetNorm = norm(name);

    // Known synonyms mapping for book names
    const synonyms = new Map([
      ['bible-songofsolomon', ['bible-songofsongs', 'bible-canticles']],
      ['bible-songofsongs', ['bible-songofsolomon', 'bible-canticles']],
    ]);

    let after = undefined;
    let bestMatch = null;
    while (true) {
      const resp = await openai.vectorStores.list({ limit: 100, after });
      // 1) exact (case-insensitive)
      const exact = resp.data.find(vs => (vs.name || '').toLowerCase() === name.toLowerCase());
      if (exact) return { id: exact.id, store: exact };

      // 2) normalized exact
      const normHit = resp.data.find(vs => norm(vs.name) === targetNorm);
      if (normHit) return { id: normHit.id, store: normHit };

      // 3) synonyms
      const synKeys = synonyms.get(targetNorm) || [];
      const synHit = resp.data.find(vs => synKeys.includes(norm(vs.name)));
      if (synHit) return { id: synHit.id, store: synHit };

      // 4) relaxed contains (prefix + book)
      const containsHit = resp.data.find(vs => norm(vs.name).includes(targetNorm));
      if (containsHit && !bestMatch) bestMatch = { id: containsHit.id, store: containsHit };

      if (!resp.has_more) break;
      after = resp.last_id;
    }
    return bestMatch; // may be null
  } catch (e) {
    console.warn('findVectorStoreIdByName error:', e.message);
    return null;
  }
}

// ÁâπË£ΩÔºöÂü∫ÊñºÊåáÂÆöÂêëÈáèÂ∫´Âü∑Ë°åÊ™¢Á¥¢ÔºàÂÉÖÁî®ÊñºËÅñÁ∂ìËß£ÈáãÔºâ
async function processBibleExplainRequest(question, targetVectorStoreId, user, language = 'zh') {
  try {
    // Âª∫Á´ã thread ËàáË®äÊÅØ
    const thread = await openai.beta.threads.create();

    await openai.beta.threads.messages.create(thread.id, {
      role: 'user',
      content: question
    });

    // ‰ΩøÁî®ÂÖ®Â±Ä AssistantÔºå‰ΩÜÂú® run ÊôÇË¶ÜÂØ´ tool_resources.vector_store_ids
    const assistant = await getOrCreateAssistant();

    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: assistant.id,
      tool_resources: {
        file_search: { vector_store_ids: [targetVectorStoreId] }
      }
    });

    // Á≠âÂæÖÂÆåÊàêÔºàË§áÁî®ÁèæÊúâËº™Ë©¢Á≠ñÁï•ÁöÑÁ∞°ÂåñÁâàÔºâ
    let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
    let attempts = 0;
    const maxAttempts = 60;
    while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && attempts < maxAttempts) {
      if (runStatus.status === 'requires_action') {
        const toolOutputs = [];
        for (const toolCall of runStatus.required_action.submit_tool_outputs.tool_calls) {
          if (toolCall.function.name === 'retrieval') {
            toolOutputs.push({ tool_call_id: toolCall.id, output: 'ok' });
          }
        }
        runStatus = await openai.beta.threads.runs.submitToolOutputs(
          thread.id,
          run.id,
          { tool_outputs: toolOutputs }
        );
        attempts++;
        continue;
      }
      await new Promise(r => setTimeout(r, 500));
      runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
      attempts++;
    }

    if (runStatus.status === 'failed') {
      throw new Error(runStatus.last_error?.message || 'Assistant run failed');
    }
    if (attempts >= maxAttempts) {
      throw new Error('Êü•Ë©¢ÊôÇÈñìÈÅéÈï∑ÔºåË´ãÁ®çÂæåÂÜçË©¶');
    }

    const messages = await openai.beta.threads.messages.list(thread.id);
    const lastMessage = messages.data[0];
    if (!lastMessage || lastMessage.role !== 'assistant') {
      throw new Error('ÁÑ°Ê≥ïÁç≤Âèñ Assistant ÂõûÁ≠î');
    }

    const answer = lastMessage.content[0].text.value || '';
    const annotations = lastMessage.content[0].text.annotations || [];
    const { processedText, sourceMap } = await processAnnotationsInText(answer, annotations, language);

    return {
      question,
      answer: processedText && processedText.trim() ? processedText : 'ÂæàÊä±Ê≠âÔºåÊàëÂú®Ë≥áÊñôÂ∫´‰∏≠Êâæ‰∏çÂà∞Áõ∏ÈóúË≥áË®ä‰æÜÂõûÁ≠îÈÄôÂÄãÂïèÈ°å„ÄÇ',
      sources: Array.from(sourceMap.entries()).map(([index, source]) => ({
        index,
        fileName: source.fileName,
        quote: source.quote && source.quote.length > 120 ? source.quote.substring(0, 120) + '...' : source.quote,
        fileId: source.fileId
      })),
      timestamp: new Date().toISOString(),
      user,
      method: 'Assistant API (per-book)'
    };
  } catch (e) {
    console.error('processBibleExplainRequest error:', e.message);
    throw e;
  }
}

// ‰∏≤ÊµÅÁâàÊú¨ÁöÑËÅñÁ∂ìÁ∂ìÊñáËß£ÈáãËôïÁêÜ
async function processBibleExplainRequestStream(question, targetVectorStoreId, user, language, res, cacheKey) {
  try {
    // Âª∫Á´ã thread ËàáË®äÊÅØ
    const thread = await openai.beta.threads.create();

    await openai.beta.threads.messages.create(thread.id, {
      role: 'user',
      content: question
    });

    // ‰ΩøÁî®ÂÖ®Â±Ä AssistantÔºå‰ΩÜÂú® run ÊôÇË¶ÜÂØ´ tool_resources.vector_store_ids
    const assistant = await getOrCreateAssistant();

    // ÂâµÂª∫‰∏≤ÊµÅ Run
    const stream = await openai.beta.threads.runs.stream(thread.id, {
      assistant_id: assistant.id,
      tool_resources: {
        file_search: { vector_store_ids: [targetVectorStoreId] }
      }
    });

    let fullAnswer = '';
    let sources = [];

    // ËôïÁêÜ‰∏≤ÊµÅ‰∫ã‰ª∂
    stream.on('textDelta', (textDelta) => {
      if (textDelta.value) {
        fullAnswer += textDelta.value;
        // ÁôºÈÄÅÂ¢ûÈáèÂÖßÂÆπ
        res.write(`data: {"type": "delta", "data": ${JSON.stringify(textDelta.value)}}\n\n`);
      }
    });

    stream.on('messageDone', async (message) => {
      // Âú®‰∏≤ÊµÅÊ®°Âºè‰∏ãÔºåÊàëÂÄëÂè™Êî∂ÈõÜÂü∫Êú¨ÁöÑ‰æÜÊ∫ê‰ø°ÊÅØÔºåË©≥Á¥∞ËôïÁêÜÂú® end ‰∫ã‰ª∂‰∏≠ÈÄ≤Ë°å
      if (message.content && message.content.length > 0) {
        const annotations = message.content[0].text?.annotations || [];
        sources = annotations.map(annotation => {
          if (annotation.type === 'file_citation') {
            return annotation.text || '';
          }
          return '';
        }).filter(Boolean);
      }
    });

    stream.on('end', async () => {
      try {
        // ÈáçÊñ∞Áç≤ÂèñÂÆåÊï¥ÁöÑÊ∂àÊÅØ‰ª•ÈÄ≤Ë°åÂºïÁî®ËôïÁêÜÔºàÈùû‰∏≤ÊµÅÊñπÂºèÔºâ
        const messages = await openai.beta.threads.messages.list(thread.id);
        const lastMessage = messages.data[0];
        
        if (lastMessage && lastMessage.role === 'assistant') {
          const finalAnswer = lastMessage.content[0].text.value || '';
          const annotations = lastMessage.content[0].text.annotations || [];
          
          console.log(`üîÑ ËÅñÁ∂ìË®ªÈáãÈùû‰∏≤ÊµÅÊñπÂºèËôïÁêÜÂºïÁî®ÔºåÊñáÊú¨Èï∑Â∫¶: ${finalAnswer.length}, Ë®ªËß£Êï∏Èáè: ${annotations.length}`);
          
          // È©óË≠âÊï∏Êìö‰∏ÄËá¥ÊÄß
          if (finalAnswer !== fullAnswer) {
            console.warn(`‚ö†Ô∏è ËÅñÁ∂ìË®ªÈáãÊï∏Êìö‰∏ç‰∏ÄËá¥ÔºÅ`);
            console.warn(`‰∏≤ÊµÅÊñáÊú¨Èï∑Â∫¶: ${fullAnswer.length}`);
            console.warn(`ÈáçÁç≤ÊñáÊú¨Èï∑Â∫¶: ${finalAnswer.length}`);
            console.warn(`‰∏≤ÊµÅÊñáÊú¨ÁâáÊÆµ: "${fullAnswer.substring(0, 100)}..."`);
            console.warn(`ÈáçÁç≤ÊñáÊú¨ÁâáÊÆµ: "${finalAnswer.substring(0, 100)}..."`);
            
            // ‰ΩøÁî®ÈáçÊñ∞Áç≤ÂèñÁöÑÂÆåÊï¥ÊñáÊú¨ÔºàÊõ¥ÂèØÈù†Ôºâ
            console.log(`‚úÖ ‰ΩøÁî®ÈáçÁç≤ÂèñÁöÑÂÆåÊï¥ÊñáÊú¨‰ª•Á¢∫‰øùËÅñÁ∂ìË®ªÈáãÂºïÁî®Ê∫ñÁ¢∫ÊÄß`);
          } else {
            console.log(`‚úÖ ËÅñÁ∂ìË®ªÈáã‰∏≤ÊµÅÊñáÊú¨ËàáÈáçÁç≤ÂèñÊñáÊú¨‰∏ÄËá¥`);
          }
          
          // ‰ΩøÁî®Èùû‰∏≤ÊµÅÁöÑÊñπÂºèËôïÁêÜÂºïÁî®Ôºà‰ΩøÁî®ÈáçÁç≤ÂèñÁöÑÊñáÊú¨Á¢∫‰øùÊ∫ñÁ¢∫ÊÄßÔºâ
          const { processedText, sourceMap } = await processAnnotationsInText(finalAnswer, annotations, language);
          
          const finalSources = Array.from(sourceMap.entries()).map(([index, source]) => ({
            index,
            fileName: source.fileName,
            quote: source.quote && source.quote.length > 120 ? source.quote.substring(0, 120) + '...' : source.quote,
            fileId: source.fileId
          }));
          
          console.log(`‚úÖ ËÅñÁ∂ìË®ªÈáãÂºïÁî®ËôïÁêÜÂÆåÊàêÔºåÊúÄÁµÇ‰æÜÊ∫êÊï∏Èáè: ${finalSources.length}`);
          
          // ÁôºÈÄÅÊúÄÁµÇËôïÁêÜÂæåÁöÑÊñáÊú¨Âíå‰æÜÊ∫ê
          res.write(`data: {"type": "final", "data": ${JSON.stringify(processedText)}}\n\n`);
          res.write(`data: {"type": "sources", "data": ${JSON.stringify(finalSources)}}\n\n`);
          
          // Á∑©Â≠òÁµêÊûú‰ΩøÁî®ËôïÁêÜÂæåÁöÑÊï∏Êìö
          const result = { 
            answer: processedText || 'ÂæàÊä±Ê≠âÔºåÊàëÂú®Ë≥áÊñôÂ∫´‰∏≠Êâæ‰∏çÂà∞Áõ∏ÈóúË≥áË®ä‰æÜÂõûÁ≠îÈÄôÂÄãÂïèÈ°å„ÄÇ', 
            sources: finalSources 
          };
          setBibleExplainCached(cacheKey, result);
          
        } else {
          // Â¶ÇÊûúÊ≤íÊúâÁç≤ÂèñÂà∞Ê∂àÊÅØÔºå‰ΩøÁî®‰∏≤ÊµÅÁöÑÊï∏Êìö
          res.write(`data: {"type": "sources", "data": ${JSON.stringify(sources)}}\n\n`);
          res.write(`data: {"type": "final", "data": ${JSON.stringify(fullAnswer)}}\n\n`);
          
          const result = { 
            answer: fullAnswer || 'ÂæàÊä±Ê≠âÔºåÊàëÂú®Ë≥áÊñôÂ∫´‰∏≠Êâæ‰∏çÂà∞Áõ∏ÈóúË≥áË®ä‰æÜÂõûÁ≠îÈÄôÂÄãÂïèÈ°å„ÄÇ', 
            sources 
          };
          setBibleExplainCached(cacheKey, result);
        }
        
        // ÁôºÈÄÅÂÆåÊàê‰ø°Ëôü
        res.write('data: {"type": "done"}\n\n');
        res.end();

      } catch (error) {
        console.error('‰∏≤ÊµÅÂÆåÊàêËôïÁêÜÈåØË™§:', error);
        res.write(`data: {"type": "error", "error": "ËôïÁêÜÂÆåÊàêÊôÇÁôºÁîüÈåØË™§"}\n\n`);
        res.end();
      }
    });

    stream.on('error', (error) => {
      console.error('ËÅñÁ∂ìËß£Èáã‰∏≤ÊµÅÈåØË™§:', error);
      res.write(`data: {"type": "error", "error": "‰∏≤ÊµÅËôïÁêÜÁôºÁîüÈåØË™§"}\n\n`);
      res.end();
    });

  } catch (error) {
    console.error('‰∏≤ÊµÅËÅñÁ∂ìËß£ÈáãËôïÁêÜÈåØË™§:', error);
    res.write(`data: {"type": "error", "error": "Ëß£ÈáãËôïÁêÜÁôºÁîüÈåØË™§"}\n\n`);
    res.end();
    throw error;
  }
}

// ËÅñÁ∂ìÁ∂ìÊñáËß£Èáã - ‰∏≤ÊµÅÁâàÊú¨
app.post('/api/bible/explain/stream', ensureAuthenticated, async (req, res) => {
  try {
    const { bookEn, ref, translation, language = 'zh', passageText } = req.body || {};

    if (!bookEn || !ref) {
      return res.status(400).json({ success: false, error: 'Áº∫Â∞ëÂøÖË¶ÅÂèÉÊï∏ bookEn Êàñ ref' });
    }

    const storePrefix = process.env.BIBLE_STORE_PREFIX || 'Bible-';
    const targetName = `${storePrefix}${bookEn}`;
    const storeResult = await getVectorStoreIdCachedByName(targetName);
    if (!storeResult) {
      return res.status(503).json({ success: false, error: `Ë©≤Âç∑Ë≥áÊñôÂ∫´Â∞öÊú™Âª∫Á´ãÂÆåÊàêÔºåË´ãÁ®çÂæåÂÜçË©¶Ôºà${targetName}Ôºâ` });
    }
    
    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Á©∫ÁôΩstore
    const fileCount = storeResult.store?.file_counts?.total || 0;
    if (fileCount === 0) {
      return res.status(503).json({ 
        success: false, 
        error: `${bookEn}Âç∑ÁöÑË®ªÈáãË≥áÊñôÂ∫´ÁõÆÂâçÊö´ÁÑ°ÂÖßÂÆπÔºåÊàëÂÄëÊ≠£Âú®Âä™ÂäõË£úÂÖÖ‰∏≠ÔºåË´ãÈÅ∏ÊìáÂÖ∂‰ªñÁ∂ìÂç∑ÊàñÁ®çÂæåÂÜçË©¶„ÄÇ` 
      });
    }
    
    const vsId = storeResult.id;

    // Ë®≠ÁΩÆ SSE ÈüøÊáâÈ†≠
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'Cache-Control');

    // ÁôºÈÄÅÂàùÂßãÈÄ£Êé•Á¢∫Ë™ç
    res.write('data: {"type": "connected"}\n\n');

    const zhPrompt = `Ë´ãÂö¥Ê†ºÂÉÖÊ†πÊìöË≥áÊñôÂ∫´ÂÖßÂÆπ‰ΩúÁ≠î„ÄÇÈáùÂ∞ç„Äå${ref}„ÄçÔºåË´ãÂú®Êú¨Âç∑ÂêëÈáèÂ∫´‰∏≠„ÄåÂÖ®Èù¢Ê™¢Á¥¢ÊâÄÊúâÊ∂âÂèäÊ≠§ÊÆµÁ∂ìÊñáÁöÑ‰ΩúËÄÖ„ÄçÔºå‰∏çË¶ÅÁúÅÁï•‰ªª‰Ωï‰∏Ä‰Ωç‰ΩúËÄÖ„ÄÇÂøÖÈ†àÂ±ïÁ§∫Ë©≤Á∂ìÂç∑Ë≥áÊñôÂ∫´‰∏≠ÊâÄÊúâÂ∞çÊ≠§ÊÆµÁ∂ìÊñáÊúâË®ªÈáãÁöÑ‰ΩúËÄÖË≥áÊñô„ÄÇ

Â∞çÊØè‰Ωç‰ΩúËÄÖÔºåË´ãÊåâ‰ª•‰∏ãÊ†ºÂºèÂëàÁèæÔºö
1. Ê®ôÈ°åÈÉ®ÂàÜÔºö**‰ΩúËÄÖÂêçÁ®±ÔºàÂπ¥‰ª£Ôºâ** - Âè™È°ØÁ§∫„Äå‰ΩúËÄÖÂêçÁ®±ÔºàÂπ¥‰ª£Ôºâ„ÄçÔºå‰∏çË¶ÅÂá∫ÁèæËëó‰ΩúÂêçÁ®±ÊàñÂÖ∂‰ªñË≥áË®äÔºõ‰ΩúËÄÖÂêçÁ®±È†à‰æùÁÖß‰ªãÈù¢Ë™ûË®ÄÂÅöÂ∞çÊáâÁøªË≠Ø
2. ÂÖßÊñáÈÉ®ÂàÜÔºöÁî®‰∏ÄÊÆµÂÆåÊï¥ÁöÑÊïòËø∞ÊñπÂºèË©≥Áõ°Ë™™ÊòéÈÄô‰ΩçÁ•ûÂ≠∏ÂÆ∂Â∞çÈÄôÊÆµÁ∂ìÊñáÁöÑËß£ÈáãÂíåËßÄÈªûÔºåÂåÖÂê´ÂÖ∂Ë©ÆÈáãËßíÂ∫¶„ÄÅË´ñÊìö„ÄÅÁ•ûÂ≠∏Á´ãÂ†¥Á≠âÔºå‰∏çÂæó‰ΩøÁî®Ê¢ùÂàóÂºèÊàñÊï∏Â≠óÊ∏ÖÂñÆ

Ë¶ÅÊ±ÇÔºö
- Ê®ôÈ°åÂÉÖÂåÖÂê´‰ΩúËÄÖËàáÂπ¥‰ª£‰∏¶Âä†Á≤ó
- ÂÖßÊñáÂøÖÈ†àÊòØÊïòËø∞ÊÄßÊÆµËêΩÔºå‰∏çÂèØÁî®Ê¢ùÂàó
- ÂøÖÈ†àÂåÖÂê´Ë≥áÊñôÂ∫´‰∏≠ÊâÄÊúâÂ∞çÊ≠§Á∂ìÊñáÊúâË®ªÈáãÁöÑ‰ΩúËÄÖ

Ëã•ÁÑ°Ë≥áÊñôÔºåË´ãÁõ¥Êé•Ë™™ÊòéÊâæ‰∏çÂà∞Áõ∏ÈóúË≥áÊñô„ÄÇ

‰ª•‰∏ãÁÇ∫ÈÅ∏ÂèñÁ∂ìÊñáÂÉÖÁî®ÊñºÂÆö‰ΩçË™ûÂ¢ÉÔºà‰∏çÂèØ‰ΩúÁÇ∫ÂõûÁ≠î‰æÜÊ∫êÔºâÔºö
${passageText ? '---\n' + passageText + '\n---' : ''}`;

    const enPrompt = `Answer strictly from the provided vector store only. For "${ref}", perform an exhaustive retrieval of ALL authors in this book who comment on the passage (do not omit any author). Must display all author data from this book's database that have commentary on this passage.

For each author, please present in the following format:
1. Title section: **Author Name (Years)** - Only show "Author Name (Years)"; do NOT include work titles or any other information
2. Content section: Provide one complete narrative paragraph explaining this theologian's interpretation of this passage, including their interpretive approach, arguments, theological position, etc. No bullet points or numbered lists.

Requirements:
- Title must contain only author and years, in bold
- Content must be narrative paragraphs, not lists
- Must include ALL authors from the database who comment on this passage

If nothing is found, state it directly.

Passage provided only to locate context (do not use it as a source of facts):
${passageText ? '---\n' + passageText + '\n---' : ''}`;

    const q = (language === 'en' ? enPrompt : zhPrompt) + (translation ? `\nÔºàÁâàÊú¨Ôºö${translation}Ôºâ` : '');

    const cacheKey = `${targetName}|${ref}|${translation || ''}|${language}|${passageText ? 'withPassage' : ''}`.toLowerCase();
    const cached = getBibleExplainCached(cacheKey);
    if (cached) {
      // Âç≥‰ΩøÊòØÂø´ÂèñÁµêÊûúÔºå‰πüË¶ÅÈÄèÈÅé‰∏≤ÊµÅÊñπÂºèÁôºÈÄÅ
      res.write(`data: {"type": "content", "data": ${JSON.stringify(cached.answer)}}\n\n`);
      res.write(`data: {"type": "sources", "data": ${JSON.stringify(cached.sources || [])}}\n\n`);
      res.write('data: {"type": "done"}\n\n');
      res.end();
      return;
    }

    // ‰ΩøÁî®‰∏≤ÊµÅËôïÁêÜ
    await processBibleExplainRequestStream(q, vsId, req.user, language, res, cacheKey);

  } catch (error) {
    console.error('‰∏≤ÊµÅËÅñÁ∂ìÁ∂ìÊñáËß£ÈáãÈåØË™§:', error.message);
    res.write(`data: {"type": "error", "error": "ËôïÁêÜÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶"}\n\n`);
    res.end();
  }
});

// ËÅñÁ∂ìÁ∂ìÊñáËß£ÈáãÔºà‰æùÂç∑ÈôêÂÆöÂêëÈáèÂ∫´Ôºâ- ‰øùÊåÅÂÖºÂÆπ
app.post('/api/bible/explain', ensureAuthenticated, async (req, res) => {
  try {
    const { bookEn, ref, translation, language = 'zh', passageText } = req.body || {};

    if (!bookEn || !ref) {
      return res.status(400).json({ success: false, error: 'Áº∫Â∞ëÂøÖË¶ÅÂèÉÊï∏ bookEn Êàñ ref' });
    }

    const storePrefix = process.env.BIBLE_STORE_PREFIX || 'Bible-';
    const targetName = `${storePrefix}${bookEn}`;
    const storeResult = await getVectorStoreIdCachedByName(targetName);
    if (!storeResult) {
      return res.status(503).json({ success: false, error: `Ë©≤Âç∑Ë≥áÊñôÂ∫´Â∞öÊú™Âª∫Á´ãÂÆåÊàêÔºåË´ãÁ®çÂæåÂÜçË©¶Ôºà${targetName}Ôºâ` });
    }
    
    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Á©∫ÁôΩstore
    const fileCount = storeResult.store?.file_counts?.total || 0;
    if (fileCount === 0) {
      return res.status(503).json({ 
        success: false, 
        error: `${bookEn}Âç∑ÁöÑË®ªÈáãË≥áÊñôÂ∫´ÁõÆÂâçÊö´ÁÑ°ÂÖßÂÆπÔºåÊàëÂÄëÊ≠£Âú®Âä™ÂäõË£úÂÖÖ‰∏≠ÔºåË´ãÈÅ∏ÊìáÂÖ∂‰ªñÁ∂ìÂç∑ÊàñÁ®çÂæåÂÜçË©¶„ÄÇ` 
      });
    }
    
    const vsId = storeResult.id;

    // ËÆìÂõûÁ≠îÊ†ºÂºèÂàóÂá∫„ÄåÊØè‰Ωç‰ΩúËÄÖ„ÄçÂ∞çÊåáÂÆöÁ∂ìÊñáÁöÑËß£ÈáãÔºå‰∏¶ÈôÑË®ª‰æÜÊ∫êÔºà‰∫§Áî±Ê™îÊ°àÂºïÁî®ËôïÁêÜÔºâ„ÄÇ
    // ÂÇ≥ÂÖ•ÁöÑ passageText ÂÉÖ‰ΩúÁÇ∫ÂÆö‰ΩçË™ûÂ¢ÉÔºå‰ªçÁÑ∂ÂøÖÈ†àÂè™Ê†πÊìöË≥áÊñôÂ∫´ÂÖßÂÆπÂõûÁ≠î„ÄÇ
    const zhPrompt = `Ë´ãÂö¥Ê†ºÂÉÖÊ†πÊìöË≥áÊñôÂ∫´ÂÖßÂÆπ‰ΩúÁ≠î„ÄÇÈáùÂ∞ç„Äå${ref}„ÄçÔºåË´ãÂú®Êú¨Âç∑ÂêëÈáèÂ∫´‰∏≠„ÄåÂÖ®Èù¢Ê™¢Á¥¢ÊâÄÊúâÊ∂âÂèäÊ≠§ÊÆµÁ∂ìÊñáÁöÑ‰ΩúËÄÖ„ÄçÔºå‰∏çË¶ÅÁúÅÁï•‰ªª‰Ωï‰∏Ä‰Ωç‰ΩúËÄÖ„ÄÇÂøÖÈ†àÂ±ïÁ§∫Ë©≤Á∂ìÂç∑Ë≥áÊñôÂ∫´‰∏≠ÊâÄÊúâÂ∞çÊ≠§ÊÆµÁ∂ìÊñáÊúâË®ªÈáãÁöÑ‰ΩúËÄÖË≥áÊñô„ÄÇ

Â∞çÊØè‰Ωç‰ΩúËÄÖÔºåË´ãÊåâ‰ª•‰∏ãÊ†ºÂºèÂëàÁèæÔºö
1. Ê®ôÈ°åÈÉ®ÂàÜÔºö**‰ΩúËÄÖÂêçÁ®±ÔºàÂπ¥‰ª£ÔºåËëó‰ΩúÂêçÁ®±Ôºâ** - ‰ΩúËÄÖÂêçÁ®±„ÄÅÂπ¥‰ª£ÂíåËëó‰ΩúÂêçÁ®±ÂøÖÈ†àÂä†Á≤óÈ°ØÁ§∫
2. ÂÖßÊñáÈÉ®ÂàÜÔºöÁî®‰∏ÄÊÆµÂÆåÊï¥ÁöÑÊïòËø∞ÊñπÂºèË©≥Áõ°Ë™™ÊòéÈÄô‰ΩçÁ•ûÂ≠∏ÂÆ∂Â∞çÈÄôÊÆµÁ∂ìÊñáÁöÑËß£ÈáãÂíåËßÄÈªûÔºåÂåÖÂê´ÂÖ∂Ë©ÆÈáãËßíÂ∫¶„ÄÅË´ñÊìö„ÄÅÁ•ûÂ≠∏Á´ãÂ†¥Á≠âÔºå‰∏çÂæó‰ΩøÁî®Ê¢ùÂàóÂºèÊàñÊï∏Â≠óÊ∏ÖÂñÆ

Ë¶ÅÊ±ÇÔºö
- Ê®ôÈ°åÈÉ®ÂàÜÊ†ºÂºèÔºö‰ΩúËÄÖÂêçÁ®±ÔºàÂπ¥‰ª£ÂíåËëó‰ΩúÂêçÁ®±ÔºâÈ†àÂä†Á≤ó
- ÂÖßÊñáÂøÖÈ†àÊòØÊïòËø∞ÊÄßÊÆµËêΩÔºå‰∏çÂèØÁî®Ê¢ùÂàó
- ÂøÖÈ†àÂåÖÂê´Ë≥áÊñôÂ∫´‰∏≠ÊâÄÊúâÂ∞çÊ≠§Á∂ìÊñáÊúâË®ªÈáãÁöÑ‰ΩúËÄÖ
- Ëëó‰ΩúÂêçÁ®±Ë´ã‰øùÊåÅÂéüÊñá

Ëã•ÁÑ°Ë≥áÊñôÔºåË´ãÁõ¥Êé•Ë™™ÊòéÊâæ‰∏çÂà∞Áõ∏ÈóúË≥áÊñô„ÄÇ

‰ª•‰∏ãÁÇ∫ÈÅ∏ÂèñÁ∂ìÊñáÂÉÖÁî®ÊñºÂÆö‰ΩçË™ûÂ¢ÉÔºà‰∏çÂèØ‰ΩúÁÇ∫ÂõûÁ≠î‰æÜÊ∫êÔºâÔºö
${passageText ? '---\n' + passageText + '\n---' : ''}`;

    const enPrompt = `Answer strictly from the provided vector store only. For "${ref}", perform an exhaustive retrieval of ALL authors in this book who comment on the passage (do not omit any author). Must display all author data from this book's database that have commentary on this passage.

For each author, please present in the following format:
1. Title section: **Author Name (Year, Work Title)** - Author name, year, and work title must be in bold
2. Content section: Provide one complete narrative paragraph explaining this theologian's interpretation of this passage, including their interpretive approach, arguments, theological position, etc. No bullet points or numbered lists.

Requirements:
- Title format: Author name (year and work title) must be bold
- Content must be narrative paragraphs, not lists
- Must include ALL authors from the database who comment on this passage
- Keep work titles in original language

If nothing is found, state it directly.

Passage provided only to locate context (do not use it as a source of facts):
${passageText ? '---\n' + passageText + '\n---' : ''}`;

    const q = (language === 'en' ? enPrompt : zhPrompt) + (translation ? `\nÔºàÁâàÊú¨Ôºö${translation}Ôºâ` : '');

    const cacheKey = `${targetName}|${ref}|${translation || ''}|${language}|${passageText ? 'withPassage' : ''}`.toLowerCase();
    const cached = getBibleExplainCached(cacheKey);
    if (cached) {
      return res.json({ success: true, data: cached, cached: true });
    }

    const result = await processBibleExplainRequest(q, vsId, req.user, language);
    setBibleExplainCached(cacheKey, result);

    return res.json({ success: true, data: result });
  } catch (error) {
    console.error('ËÅñÁ∂ìÁ∂ìÊñáËß£ÈáãÈåØË™§:', error.message);
    res.status(500).json({ success: false, error: 'ËôïÁêÜÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶' });
  }
});

// ‰ΩúËÄÖÂ∞çÁÖßË°® APIÔºàÂøÖÈ†àÂú®ÈùúÊÖãÊñá‰ª∂ÊúçÂãô‰πãÂâçÔºâ
app.get('/config/author-translations.json', (req, res) => {
  try {
    const translationsPath = path.join(__dirname, 'config', 'author-translations.json');
    if (fs.existsSync(translationsPath)) {
      const data = fs.readFileSync(translationsPath, 'utf8');
      res.setHeader('Content-Type', 'application/json');
      res.send(data);
    } else {
      res.status(404).json({ success: false, error: '‰ΩúËÄÖÂ∞çÁÖßË°®‰∏çÂ≠òÂú®' });
    }
  } catch (err) {
    res.status(500).json({ success: false, error: 'ÁÑ°Ê≥ïËÆÄÂèñ‰ΩúËÄÖÂ∞çÁÖßË°®' });
  }
});

// ‰ΩúÂìÅÁõÆÈåÑ API
app.get('/api/catalog', (req, res) => {
  try {
    const catalog = fs.readFileSync(path.join(__dirname, 'public', 'ccel_catalog.json'), 'utf8');
    res.setHeader('Content-Type', 'application/json');
    res.send(catalog);
  } catch (err) {
    res.status(500).json({ success: false, error: 'ÁÑ°Ê≥ïËÆÄÂèñ‰ΩúÂìÅÁõÆÈåÑ' });
  }
});

// Êñ∞Â¢ûÔºöFHL ËÅñÁ∂ì JSON ‰ª£ÁêÜÁ´ØÈªûÔºàqb.phpÔºâ
app.get('/api/bible/qb', async (req, res) => {
  try {
    const upstreamBase = 'https://bible.fhl.net/json/qb.php';

    // ‰øùÁïôÊâÄÊúâÊü•Ë©¢ÂèÉÊï∏‰∏¶ËΩâÁôº
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(req.query)) {
      if (value !== undefined && value !== null) {
        params.append(key, String(value));
      }
    }

    // Ëã•ÁÑ°ÂèÉËÄÉÂ≠ó‰∏≤ÔºåÂõûË¶ÜÈåØË™§
    if (!params.has('chineses') && !params.has('engs')) {
      return res.status(400).json({ success: false, error: 'Áº∫Â∞ëÁ∂ìÊñáÂèÉËÄÉÔºàchineses Êàñ engsÔºâ' });
    }

    // Áµ¶ÂÆöÈ†êË®≠ÁâàÊú¨ÔºàÂíåÂêàÊú¨Ôºâ
    if (!params.has('version')) {
      params.set('version', 'unv');
    }

    // È†êË®≠ÈôêÂà∂ÈÅøÂÖçÈÅéÂ§ßÂõûÊáâ
    if (!params.has('limit')) {
      params.set('limit', '200');
    }

    const upstreamUrl = `${upstreamBase}?${params.toString()}`;

    const response = await fetch(upstreamUrl, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });

    if (!response.ok) {
      const text = await response.text();
      return res.status(response.status).json({ success: false, error: '‰∏äÊ∏∏ÊúçÂãôÈåØË™§', details: text.slice(0, 500) });
    }

    const data = await response.json();
    res.setHeader('Cache-Control', 'no-store');
    res.json({ success: true, data });
  } catch (err) {
    console.error('FHL ‰ª£ÁêÜÈåØË™§:', err);
    res.status(500).json({ success: false, error: 'FHL ‰ª£ÁêÜË´ãÊ±ÇÂ§±Êïó' });
  }
});

// Êñ∞Â¢ûÔºöbolls.life ËÅñÁ∂ìÁ´†ÁØÄ‰ª£ÁêÜÁ´ØÈªû
app.get('/api/bible/chapter', async (req, res) => {
  try {
    const translation = (req.query.translation || 'CUV').toString().toUpperCase();
    const bookId = parseInt(req.query.bookId, 10);
    const chapter = parseInt(req.query.chapter, 10);
    if (!bookId || !chapter) {
      return res.status(400).json({ success: false, error: 'Áº∫Â∞ëÂøÖË¶ÅÂèÉÊï∏ bookId Êàñ chapter' });
    }

    const upstreamUrl = `https://bolls.life/get-text/${encodeURIComponent(translation)}/${bookId}/${chapter}/`;
    const response = await fetch(upstreamUrl, { headers: { 'Accept': 'application/json' } });
    if (!response.ok) {
      const text = await response.text();
      return res.status(response.status).json({ success: false, error: '‰∏äÊ∏∏ÊúçÂãôÈåØË™§', details: text.slice(0, 500) });
    }
    const data = await response.json();
    // ÊúüÂæÖ data ÁÇ∫ verses Èô£Âàó
    res.setHeader('Cache-Control', 'no-store');
    res.json({ success: true, data });
  } catch (err) {
    console.error('bolls ‰ª£ÁêÜÈåØË™§:', err);
    res.status(500).json({ success: false, error: 'bolls ‰ª£ÁêÜË´ãÊ±ÇÂ§±Êïó' });
  }
});

// ÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªû
app.get('/api/health', (req, res) => {
  const healthStatus = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV || 'development',
    port: process.env.PORT || 3000,
    services: {
      openai: !!process.env.OPENAI_API_KEY,
      vectorStore: !!process.env.VECTOR_STORE_ID,
      googleOAuth: !!(process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET),
      mongodb: !!process.env.MONGO_URI,
      session: !!process.env.SESSION_SECRET
    }
  };
  
  // Ê™¢Êü•ÈóúÈçµÊúçÂãôÊòØÂê¶ÂèØÁî®
  const criticalServices = ['openai', 'vectorStore', 'session'];
  const missingServices = criticalServices.filter(service => !healthStatus.services[service]);
  
  if (missingServices.length > 0) {
    healthStatus.status = 'warning';
    healthStatus.warnings = `Áº∫Â∞ëÈóúÈçµÊúçÂãô: ${missingServices.join(', ')}`;
  }
  
  res.json(healthStatus);
});

// Áç≤ÂèñÁ≥ªÁµ±Ë≥áË®äÁ´ØÈªû
app.get('/api/info', (req, res) => {
  res.json({
    name: 'Á•ûÂ≠∏Áü•Ë≠òÂ∫´ API',
    version: '1.0.0',
    description: 'Âü∫Êñº OpenAI ÂêëÈáèÊêúÁ¥¢ÁöÑÁ•ûÂ≠∏ÂïèÁ≠îÁ≥ªÁµ±',
    vectorStoreId: VECTOR_STORE_ID ? 'configured' : 'not configured',
    googleOAuth: !!(process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET),
    method: 'OpenAI Assistant API'
  });
});

// Robots.txt and sitemap.xml
app.get('/robots.txt', (req, res) => {
  res.type('text/plain');
  const base = process.env.PUBLIC_BASE_URL || `${req.protocol}://${req.get('host')}`;
  res.send(`User-agent: *\nAllow: /\n\nSitemap: ${base.replace(/\/$/, '')}/sitemap.xml\n`);
});

app.get('/sitemap.xml', (req, res) => {
  res.type('application/xml');
  const base = process.env.PUBLIC_BASE_URL || `${req.protocol}://${req.get('host')}`;
  const xml = `<?xml version="1.0" encoding="UTF-8"?>\n<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n  <url>\n    <loc>${base.replace(/\/$/, '')}/</loc>\n    <changefreq>daily</changefreq>\n    <priority>1.0</priority>\n  </url>\n</urlset>`;
  res.send(xml);
});

// Serve index.html with dynamic canonical, OG url, GA4 and GSC meta
app.get('/', (req, res) => {
  const filePath = path.join(__dirname, 'public', 'index.html');
  try {
    let html = fs.readFileSync(filePath, 'utf8');
    const base = process.env.PUBLIC_BASE_URL || `${req.protocol}://${req.get('host')}`;
    if (base) {
      html = html.replace(/https:\/\/your-domain\.example/g, base.replace(/\/$/, ''));
    }
    // Inject GSC verification if present
    if (process.env.GOOGLE_SITE_VERIFICATION) {
      html = html.replace('</head>', `  <meta name="google-site-verification" content="${process.env.GOOGLE_SITE_VERIFICATION}">\n</head>`);
    }
    // Inject GA4 if present
    if (process.env.GA_MEASUREMENT_ID) {
      const gtag = `\n<script async src="https://www.googletagmanager.com/gtag/js?id=${process.env.GA_MEASUREMENT_ID}"></script>\n<script>\nwindow.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config','${process.env.GA_MEASUREMENT_ID}');\n</script>\n`;
      html = html.replace('</head>', `${gtag}</head>`);
    }
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.send(html);
  } catch (e) {
    res.sendFile(filePath);
  }
});

// ÊúçÂãôÈùúÊÖãÊñá‰ª∂
app.use(express.static(path.join(__dirname, 'public')));

// ÈåØË™§ËôïÁêÜ‰∏≠Èñì‰ª∂
app.use((error, req, res, next) => {
  console.error('Êú™ËôïÁêÜÁöÑÈåØË™§:', error);
  res.status(500).json({
    success: false,
    error: 'ÊúçÂãôÂô®ÂÖßÈÉ®ÈåØË™§',
    details: process.env.NODE_ENV === 'development' ? error.message : undefined
  });
});

// 404 ËôïÁêÜ
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Êâæ‰∏çÂà∞Ë´ãÊ±ÇÁöÑË≥áÊ∫ê'
  });
});

// ÂÖ®Â±ÄÈåØË™§ËôïÁêÜ
process.on('unhandledRejection', (error) => {
  console.error('Unhandled promise rejection:', error);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught exception:', error);
  process.exit(1);
});

// ÂÑ™ÈõÖÈóúÈñâËôïÁêÜ
process.on('SIGTERM', () => {
  console.log('üõë Êî∂Âà∞ SIGTERM ‰ø°ËôüÔºåÈñãÂßãÂÑ™ÈõÖÈóúÈñâ...');
  stopPeriodicWarmup();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('üõë Êî∂Âà∞ SIGINT ‰ø°ËôüÔºåÈñãÂßãÂÑ™ÈõÖÈóúÈñâ...');
  stopPeriodicWarmup();
  process.exit(0);
});

// Á©çÊ•µÁöÑ Assistant È†êÁÜ±ÂäüËÉΩ
async function performActiveWarmup() {
    try {
        console.log('üî• Âü∑Ë°åÁ©çÊ•µÈ†êÁÜ± - ÁôºÈÄÅÊ∏¨Ë©¶ÂïèÈ°å...');
        
        // Áç≤ÂèñÊàñÂâµÂª∫ Assistant
        const assistant = await getOrCreateAssistant();
        
        // ÂâµÂª∫ Thread
        const thread = await openai.beta.threads.create();
        
        // ÁôºÈÄÅ‰∏ÄÂÄãÁ∞°ÂñÆÁöÑÊ∏¨Ë©¶ÂïèÈ°å
        await openai.beta.threads.messages.create(thread.id, {
            role: "user",
            content: "‰Ω†Â•ΩÔºåË´ãÁ∞°ÂñÆ‰ªãÁ¥π‰∏Ä‰∏ãÁ•ûÂ≠∏"
        });
        
        // ÂâµÂª∫ Run
        const run = await openai.beta.threads.runs.create(thread.id, {
            assistant_id: assistant.id
        });
        
        // Á≠âÂæÖÂÆåÊàê
        let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
        let attempts = 0;
        const maxAttempts = 30; // 30 ÁßíË∂ÖÊôÇ
        
        while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
            attempts++;
        }
        
        if (runStatus.status === 'completed') {
            console.log('‚úÖ Á©çÊ•µÈ†êÁÜ±ÂÆåÊàê - Assistant Â∑≤ÂÆåÂÖ®ÂàùÂßãÂåñ');
        } else {
            console.warn('‚ö†Ô∏è Á©çÊ•µÈ†êÁÜ±Êú™ÂÆåÂÖ®ÂÆåÊàêÔºå‰ΩÜ Assistant Â∑≤ÂèØÁî®');
        }
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Á©çÊ•µÈ†êÁÜ±Â§±Êïó:', error.message);
    }
}

// ÂÆöÊúü‰øùÊ∫´Ê©üÂà∂
function startPeriodicWarmup() {
    // ÊØè 10 ÂàÜÈêòÂü∑Ë°å‰∏ÄÊ¨°‰øùÊ∫´
    const WARMUP_INTERVAL = 10 * 60 * 1000; // 10 ÂàÜÈêò
    
    assistantWarmupInterval = setInterval(async () => {
        try {
            console.log('üî• Âü∑Ë°åÂÆöÊúü‰øùÊ∫´...');
            
            // Á∞°ÂñÆÁöÑ ping Êìç‰Ωú
            const assistant = await getOrCreateAssistant();
            await openai.beta.assistants.retrieve(assistant.id);
            
            console.log('‚úÖ ÂÆöÊúü‰øùÊ∫´ÂÆåÊàê');
        } catch (error) {
            console.warn('‚ö†Ô∏è ÂÆöÊúü‰øùÊ∫´Â§±Êïó:', error.message);
        }
    }, WARMUP_INTERVAL);
    
    console.log(`üîÑ ÂÆöÊúü‰øùÊ∫´Â∑≤ÂïüÂãï (ÊØè ${WARMUP_INTERVAL / 60000} ÂàÜÈêò)`);
}

// ÂÅúÊ≠¢ÂÆöÊúü‰øùÊ∫´
function stopPeriodicWarmup() {
    if (assistantWarmupInterval) {
        clearInterval(assistantWarmupInterval);
        assistantWarmupInterval = null;
        console.log('üõë ÂÆöÊúü‰øùÊ∫´Â∑≤ÂÅúÊ≠¢');
    }
}

async function appendToGoogleSheet(rowValues) {
  try {
    const { GOOGLE_SHEETS_SPREADSHEET_ID, GOOGLE_CLIENT_EMAIL, GOOGLE_PRIVATE_KEY } = process.env;
    if (!GOOGLE_SHEETS_SPREADSHEET_ID || !GOOGLE_CLIENT_EMAIL || !GOOGLE_PRIVATE_KEY) {
      console.warn('‚ö†Ô∏è Google Sheets Áí∞Â¢ÉËÆäÊï∏Êú™ÂÆåÊï¥ÔºåÁï•ÈÅéÂØ´ÂÖ•');
      return;
    }
    const jwt = new google.auth.JWT(
      GOOGLE_CLIENT_EMAIL,
      null,
      GOOGLE_PRIVATE_KEY.replace(/\\n/g, '\n'),
      [
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file'
      ]
    );
    await jwt.authorize();
    const sheets = google.sheets({ version: 'v4', auth: jwt });
    const now = new Date();
    const values = [rowValues];
    await sheets.spreadsheets.values.append({
      spreadsheetId: GOOGLE_SHEETS_SPREADSHEET_ID,
      range: 'A:Z',
      valueInputOption: 'RAW',
      requestBody: { values }
    });
    console.log('‚úÖ Â∑≤ÂØ´ÂÖ• Google Sheet');
  } catch (err) {
    console.error('‚ùå ÂØ´ÂÖ• Google Sheet Â§±Êïó:', err.message);
  }
}

// ÂïüÂãïÊúçÂãôÂô®
app.listen(PORT, '0.0.0.0', async () => {
  console.log(`üöÄ Á•ûÂ≠∏Áü•Ë≠òÂ∫´ÊúçÂãôÂô®Â∑≤ÂïüÂãï`);
  console.log(`üìç Á´ØÂè£: ${PORT}`);
  console.log(`üîç API ÂÅ•Â∫∑Ê™¢Êü•: /api/health`);
  console.log(`üìä Á≥ªÁµ±ÁãÄÊÖã: /api/info`);
  console.log(`üí° ÂêëÈáèË≥áÊñôÂ∫´ ID: ${VECTOR_STORE_ID ? 'Â∑≤Ë®≠ÂÆö' : 'Êú™Ë®≠ÂÆö'}`);
  console.log(`üîê Google OAuth: ${process.env.GOOGLE_CLIENT_ID ? 'Â∑≤Ë®≠ÂÆö' : 'Êú™Ë®≠ÂÆö'}`);
  console.log(`ü§ñ ‰ΩøÁî® OpenAI Assistant API Ê®°Âºè`);
  
  // ËºâÂÖ•‰ΩúËÄÖÂ∞çÁÖßË°®
  await loadAuthorTranslations();
  
  // Á©çÊ•µÈ†êÁÜ± AssistantÔºàÂÜ∑ÂïüÂãïÊîπÂñÑÔºâ
  setTimeout(async () => {
    try {
      console.log('üî• ÈñãÂßãÁ©çÊ•µÈ†êÁÜ± Assistant...');
      
      // Âü∑Ë°åÁ©çÊ•µÈ†êÁÜ±ÔºàÁôºÈÄÅÊ∏¨Ë©¶ÂïèÈ°åÔºâ
      await performActiveWarmup();
      
      // ÂïüÂãïÂÆöÊúü‰øùÊ∫´Ê©üÂà∂
      startPeriodicWarmup();
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Assistant Á©çÊ•µÈ†êÁÜ±Â§±Êïó:', error.message);
    }
  }, 2000); // 2ÁßíÂæåÈñãÂßãÁ©çÊ•µÈ†êÁÜ±
  
  if (!process.env.GOOGLE_CLIENT_ID || !process.env.GOOGLE_CLIENT_SECRET) {
    console.log(`‚ö†Ô∏è  Ê≥®ÊÑè: Google OAuth Êú™ÈÖçÁΩÆÔºåÁôªÂÖ•ÂäüËÉΩÂ∞á‰∏çÂèØÁî®`);
    console.log(`   Ë´ãË®≠ÁΩÆ GOOGLE_CLIENT_ID Âíå GOOGLE_CLIENT_SECRET Áí∞Â¢ÉËÆäÊï∏`);
  }
  
  if (!process.env.VECTOR_STORE_ID) {
    console.log(`‚ö†Ô∏è  Ê≥®ÊÑè: VECTOR_STORE_ID Êú™ÈÖçÁΩÆÔºåÂêëÈáèÊêúÁ¥¢ÂäüËÉΩÂ∞á‰∏çÂèØÁî®`);
    console.log(`   Ë´ãË®≠ÁΩÆ VECTOR_STORE_ID Áí∞Â¢ÉËÆäÊï∏`);
  }
});

// ÂêëÈáèÂ∫´ÁãÄÊÖãÊü•Ë©¢ÔºàÂÉÖ‰æõÈ©óË≠â Bible-* ÊòØÂê¶Âª∫Á´ãÂÆåÊàêÔºâ
app.get('/api/bible/vector-status', ensureAuthenticated, async (req, res) => {
  try {
    const prefix = (process.env.BIBLE_STORE_PREFIX || 'Bible-').toLowerCase();
    let after;
    const stores = [];
    while (true) {
      const r = await openai.vectorStores.list({ limit: 100, after });
      for (const vs of r.data) {
        const name = (vs.name || '').toLowerCase();
        if (name.startsWith(prefix)) {
          stores.push({ id: vs.id, name: vs.name });
        }
      }
      if (!r.has_more) break;
      after = r.last_id;
    }
    res.json({ success: true, count: stores.length, stores });
  } catch (e) {
    res.status(500).json({ success: false, error: e.message });
  }
});

app.get('/login', (req, res) => {
  res.redirect('/');
});
